import { Aside } from "~/components/configurable/Aside";

<Title>Solid Router</Title>

In modern web development a router is a software component that is responsible for handling client requests and determining which component to render whether that be through server-side or client-side routing. Once a request is made on the client the router assesses the URL and decides which controller or server-side component should handle this request or be rendered.

Solid Router is a simple and easy to use universal router for Solid.js applications. It works both on the client and on the server. The routes are defined using a simple JSX syntax and can be nested. However, routes can also be passed as a configuration object.

Solid Router has a lot of cool features and one of those is it's ability to support nested routing which allows it to change a particular part of a component instead of replacing it completely.

It supports all of Solid's SSR methods and has Solid's transitions baked in, so use it freely with suspense, resources, and lazy components. Solid Router also allows you to define a data function that loads parallel to the routes ([render-as-you-fetch](https://epicreact.dev/render-as-you-fetch/)).

<Aside>
  For more information on Solid Router, please visit the{" "}<a href="https://github.com/solidjs/solid-router#getting-started">Solid Router GitHub page</a>.
</Aside>

## Getting Started

In order to get started with Solid Router you will need to install it into your project since it is not installed by default. Once that's done we will need to setup the router and define some routes.

#### Installation

Let's jump into installing the router. To do this we will need to install the router using NPM, Yarn, or your favorite package manager.

```bash
npm install @solidjs/router
```

#### Setup

Now that we have the router installed we can setup the router and define some routes. Let's start by importing the router into our root `App` component.

```jsx
import { render } from "solid-js/web";
import App from "./App";
import { Router } from "@solidjs/router"; // ðŸ‘ˆ Import the router

render(
  () => (
    <Router>
      {" "}
      {/* ðŸ‘ˆ Wrap the router around the app */}
      <App />
    </Router>
  ),
  document.getElementById("app")
);
```

Now that we have the router setup we can define some routes. Let's start by making our `App` component our home page or `/` route.

```jsx
import { render } from "solid-js/web";
import App from "./App";
import { Router, Route, Routes } from "@solidjs/router";

render(
  () => (
    <Router>
      <Routes>
        <Route path="/" component={App} /> {/* ðŸ‘ˆ Define the home page route */}
      </Routes>
    </Router>
  ),
  document.getElementById("app")
);
```

In the code above we have imported the `Route` and `Routes` component from Solid Router and defined a route for the home page. The `Route` component takes a `path` prop which is the URL path that the route will match. The `component` prop is the component that will be rendered when the route is matched. The `Routes` component is used to group routes together and is required for nested routes. This component is used to show where the routes should be rendered.

You can add multiple routes under the `Routes` component and they will be rendered whenever the URL matches the route's path. Let's add a route for the `/about` and `/contact` pages.

```jsx
import { render } from "solid-js/web";
import App from "./App";
import About from "./About";
import Contact from "./Contact";
import { Router, Route, Routes } from "@solidjs/router";

render(
  () => (
    <Router>
      <Routes>
        <Route path="/" component={App} />
        <Route path="/about" component={About} /> {/* ðŸ‘ˆ Define the about page route */}
        <Route path="/contact" component={Contact} />{" "}
        {/* ðŸ‘ˆ Define the contact page route */}
      </Routes>
    </Router>
  ),
  document.getElementById("app")
);
```

__Note:__ If you would like to lazy load your components so that they are only loaded when the route is matched you can use the `lazy` function from `solid-js` to lazy load your components.

```jsx
import { render } from "solid-js/web";
import App from "./App";
import { Router, Route, Routes } from "@solidjs/router";
import { lazy } from "solid-js";

const About = lazy(() => import("./About"));
const Contact = lazy(() => import("./Contact"));

render(
  () => (
    <Router>
      <Routes>
        <Route path="/" component={App} />
        <Route path="/about" component={About} /> {/* ðŸ‘ˆ Define the about page route */}
        <Route path="/contact" component={Contact} />{" "}
        {/* ðŸ‘ˆ Define the contact page route */}
      </Routes>
    </Router>
  ),
  document.getElementById("app")
);
```

Now that we have our routes defined we can navigate to the `/about` and `/contact` pages. Let's add some links to our `App` component so we can navigate to the other pages. You can add links to your routes using the `A` component from Solid Router. Let's add links to the `/about` and `/contact` pages.

```jsx
import styles from "./App.module.css";
import { A } from "@solidjs/router"; // ðŸ‘ˆ Import the A component

const App = () => {
  return (
    <div class={styles.App}>
      <header class={styles.header}>
        <p>
          Edit <code>src/App.tsx</code> and save to reload.
        </p>
        <a
          class={styles.link}
          href="https://github.com/solidjs/solid"
          target="_blank"
          rel="noopener noreferrer"
        >
          Learn Solid
        </a>
        <A href="/about">About</A> {/* ðŸ‘ˆ Add a link to the about page */}
        <A href="/contact">Contact</A> {/* ðŸ‘ˆ Add a link to the contact page */}
      </header>
    </div>
  );
};

export default App;
```

## Creating links to other routes

#### The `A` component

The `A` component is used to create links to other routes in your application. The `A` component also takes in the `href` prop which is the URL path that the link will navigate to. The `A` component also takes in the `activeClass` prop which is the class that will be applied to the link when the current route path matches that of the link's path.

Here's a quick example of how a base Solid.js application with Solid Router might look, and how to use the `A` component.

```jsx
import { render } from "solid-js/web";
import App from "./App";
import About from "./About";
import Contact from "./Contact";
import { Router, Route, Routes, A } from "@solidjs/router";

render(
  () => (
    <Router>
      <Routes>
        <Route path="/" component={App} />
        <Route path="/about" component={About} />
        <Route path="/contact" component={Contact} />
      </Routes>
    </Router>
  ),
  document.getElementById("app")
);
```

Here's an example of how to make use of the `A` component and it's `activeClass` prop.

```jsx
import styles from "./App.css";
import { A } from "@solidjs/router";

const App = () => {
  return (
    <div class={styles.App}>
      <header class={styles.header}>
        <p>
          Edit <code>src/App.tsx</code> and save to reload.
        </p>
        <A
          class={styles.link}
          href="/about"
          activeClass="underlined" // ðŸ‘ˆ Add the active class
        >
          About
        </A>
        <A
          class={styles.link}
          href="/contact"
          activeClass="underlined" // ðŸ‘ˆ Add the active class
        >
          Contact
        </A>
      </header>
    </div>
  );
};

export default App;
```

**Note:** Be careful when using the **`activeClass`** prop, because by default matching includes that are descendants or otherwise nested within the matched path (e.g. `/about` will match `/about/me` and `/about/me/you`). However, you can use the **`end`** boolean prop to match on the exact path (e.g. `/about` will only match `/about`). The **`end`** prop is particularly useful for links to the root route `/` which would match all paths.

Here's a list of all the props that the `A` component takes in.

| Prop            | Type      | Description                                                                                                                                                                              |
| --------------- | --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `href`          | `string`  | The path of the route to navigate to. This will be resolved relative to the route that the link is in, but you can preface it with / to refer back to the root.                          |
| `activeClass`   | `string`  | The class that will be applied to the link when the current route path matches that of the link's path.                                                                                  |
| `end`           | `boolean` | If `true`, only considers the link to be active when the curent location matches the `href` exactly; if `false`, check if the current location starts with `href`                        |
| `noScroll`      | `boolean` | If true, turn off the default behavior of scrolling to the top of the new page                                                                                                           |
| `replace`       | `boolean` | If true, don't add a new entry to the browser history. (By default, the new page will be added to the browser history, so pressing the back button will take you to the previous route.) |
| `state`         | `unknown` | [Push this value](https://developer.mozilla.org/en-US/docs/Web/API/History/pushState) to the history stack when navigating                                                               |
| `inactiveClass` | `string`  | The class to show when the link is inactive (when the current location doesn't match the link)                                                                                           |

#### The `Navigate` component

Solid Router provides a `Navigate` component that works similarly to `A`, but it will immediately navigate to the provided path as soon as the component is rendered. It also uses the `href` prop, but you have the additional option of passing a function to `href` that returns a path to navigate to:

```jsx
function getPath ({navigate, location}) {
  //navigate is the result of calling useNavigate(); location is the result of calling useLocation(). 
  //You can use those to dynamically determine a path to navigate to
  return "/some-path";
}

//Navigating to /redirect will redirect you to the result of getPath
<Route path="/redirect" element={<Navigate href={getPath}/>}/>
```

## Dynamic Routes

If you don't know the path ahead of time, you might want to treat part of the path as a flexible parameter that is passed on to the component. For instance if you would like to navigate to a blog post with a particular ID you might want to use a dynamic route.

Here's a quick example of how to create a dynamic route.

```jsx
import { render } from "solid-js/web";
import App from "./App";
import About from "./About";
import User from "./User";
import Contact from "./Contact";
import { Router, Route, Routes, A } from "@solidjs/router";

render(
  () => (
    <Router>
      <Routes>
        <Route path="/" component={App} />
        <Route path="/about" component={About} />
        <Route path="/user/:id" component={User} /> {/* ðŸ‘ˆ Add a dynamic route */}
        <Route path="/contact" component={Contact} />
      </Routes>
    </Router>
  ),
  document.getElementById("app")
);
```

In the code snippet above we added a dynamic route named `user` that takes in a `:id` parameter. The `:id` parameter will be passed to the `User` component through the `useParams` primitive. More on Solid Router primitives later.

Here's an example of how to use the dynamic route in the `User` component.

```jsx
import styles from "./User.module.css";
import { useParams } from "@solidjs/router";

const User = () => {
  const params = useParams(); // ðŸ‘ˆ Get the dynamic route parameters

  return (
    <div class={styles.User}>
      <header class={styles.header}>
        <p>
          Edit <code>src/User.tsx</code> and save to reload.
        </p>
        <A class={styles.link} href="/">
          Home
        </A>
        <A class={styles.link} href="/about">
          About
        </A>
        <A class={styles.link} href="/contact">
          Contact
        </A>
        <p>
          This is the user with the id of <code>{params.id}</code> {/* ðŸ‘ˆ Access the dynamic route parameter */}
        </p>
      </header>
    </div>
  );
};

export default User;
```

You can make use of the `params` object to access the dynamic route parameters. In the example above we accessed the `id` parameter. You can make use of the parameters even in primitives like `createResource` and `createSignal`:

Here's an example of what this might look like in a `createResource` primitive:

```jsx
import { createResource, createSignal } from "solid-js";
import { useParams } from "@solidjs/router";

// ðŸ‘‡ This is an asynchronous function that fetches a user from the jsonplaceholder API
async function fetchUser(id) {
  const response = await fetch(`https://jsonplaceholder.typicode.com/users/${id}`);
  return response.json();
}

const User = () => {
  const params = useParams();
  const [data] = createResource(params.id,fetchUser) // ðŸ‘ˆ Pass the dynamic route parameter to the createResource primitive

  return (
    <div>
      {data.loading ? ( // ðŸ‘ˆ Use the loading property to show a loading indicator
        <p>Loading...</p>
      ) : (
        <div>
          <p>Name: {data().name}</p> {/* ðŸ‘ˆ Access the data returned from the fetchUser function */}
          <p>Email: {data().email}</p>
          <p>Phone: {data().phone}</p>
        </div>
      )}
    </div>
  );
};

export default User;
```

In the above code snippet we passed the `id` parameter to the `createResource` primitive. This means that the `fetchUser` function will be called every time the `id` parameter changes. This is useful if you want to fetch new user data every time the `id` parameter changes.

#### Optional Parameters

You can also make a parameter optional by adding a `?` after the parameter name. For example, if you want to make the `id` parameter optional you can do the following:

```jsx
import { render } from "solid-js/web";
import App from "./App";
import About from "./About";
import User from "./User";
import Contact from "./Contact";
import { Router, Route, Routes, A } from "@solidjs/router";

render(
  () => (
    <Router>
      <Routes>
        <Route path="/" component={App} />
        <Route path="/about" component={About} />
        <Route path="/user/:id?" component={User} /> {/* ðŸ‘ˆ Make the id parameter optional */}
        <Route path="/contact" component={Contact} />
      </Routes>
    </Router>
  ),
  document.getElementById("app")
);
```

The optional `/user/:id?` route will match `/user` and `/user/123` but not `/user/123/comment`.

#### Wildcard Routes/Parameters

Wildcard routes are routes that match any descendant path within a given path.

You can also make a parameter a wildcard by adding a `*` after the parameter name. For example, if you want to make the `id` parameter a wildcard you can do the following:

```jsx
import { render } from "solid-js/web";
import App from "./App";
import About from "./About";
import User from "./User";
import Contact from "./Contact";
import { Router, Route, Routes, A } from "@solidjs/router";

render(
  () => (
    <Router>
      <Routes>
        <Route path="/" component={App} />
        <Route path="/about" component={About} />
        <Route path="/user/*" component={User} /> {/* ðŸ‘ˆ Make the id parameter a wildcard */}
        <Route path="/contact" component={Contact} />
      </Routes>
    </Router>
  ),
  document.getElementById("app")
);
```

The wildcard `/user/*` route will match `/user`, `/user/123`, `/user/123/comment`, `/user/123/comment/456`, etc.

If you would like to access the wildcard parameter you can name it:

```jsx
import { render } from "solid-js/web";
import App from "./App";
import About from "./About";
import User from "./User";
import Contact from "./Contact";
import { Router, Route, Routes, A } from "@solidjs/router";

render(
  () => (
    <Router>
      <Routes>
        <Route path="/" component={App} />
        <Route path="/about" component={About} />
        <Route path="/user/*id" component={User} /> {/* ðŸ‘ˆ Name the wildcard parameter */}
        <Route path="/contact" component={Contact} />
      </Routes>
    </Router>
  ),
  document.getElementById("app")
);
```

You can access the wildcard parameter the same way you would access a dynamic route parameter:

```jsx
import styles from "./User.module.css";
import { useParams } from "@solidjs/router";

const User = () => {
  const params = useParams(); // ðŸ‘ˆ Get the wildcard route parameters

  return (
    <div class={styles.User}>
      <header class={styles.header}>
        <p>
          Edit <code>src/User.tsx</code> and save to reload.
        </p>
        <A class={styles.link} href="/">
          Home
        </A>
        <A class={styles.link} href="/about">
          About
        </A>
        <A class={styles.link} href="/contact">
          Contact
        </A>
        <p>
          This is the wildcard parameter <code>{params.id}</code> {/* ðŸ‘ˆ Access the wildcard parameter */}
        </p>
      </header>
    </div>
  );
};

export default User;
```

__Note:__ The wildcard token `*` must be the last token in the route path. For instance `/user/*id` is valid but `/user/id*` and `/user/*id/foo` is not.

#### Multiple Paths

Routes also support defining multiple paths using an array. This allows a route to remain mounted and not rerender when switching between two or more locations that it matches:

```jsx
//Navigating from login to register does not cause the Login component to re-render
<Route path={["login", "register"]} component={Login}/>
```

## Data Functions