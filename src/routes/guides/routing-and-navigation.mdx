---
title: Routing & Navigation
order: 4
---

import { TabsCodeBlocks } from "~/ui/tab-code-blocks";

Solid Router simplifies routing in Solid applications to help developers manage navigation and rendering by defining routes using JSX or objects passed via props.

## Getting Started


**1. Install the Router**

This package is not included by default.

<TabsCodeBlocks>
<div id="npm">
```bash frame="none"
npm install @solidjs/router
```
</div>

<div id="yarn">
```bash frame="none"
 yarn add @solidjs/router
```
</div>
<div id="pnpm">
```bash frame="none"
pnpm i @solidjs/router
```
</div>
</TabsCodeBlocks>

**2. Setup the `<Router>` component**

Start your application by rendering the [Router](/solid-router/reference/components/router) component.
This component will match the URL to display the desired page.

```jsx
import { render } from "solid-js/web";
import { Router } from "@solidjs/router";

render(
  () => <Router />,
  document.getElementById("root")
);
```


**3. Provide a Root Level Layout**

This layout will not update on page change and is the ideal place for top-level navigation and [Context Providers](/concepts/context).

```jsx
import { render } from "solid-js/web";
import { Router } from "@solidjs/router";

const App = props => (
  <>
    <h1>Site Title</h1>
    {props.children}
  </>
)

render(() => (
  <Router root={App} />
), document.getElementById("root"));
```

**4. Add routes**

Each route is added to the `Router` using the [`Route`](/solid-router/reference/components/route) component.
Here, you specify a path and a component to render once the user navigates to that path.

```jsx
import { render } from "solid-js/web";
import { Router, Route } from "@solidjs/router";

import Home from "./pages/Home";
import Users from "./pages/Users";

const App = props => (
  <>
    <h1>Site Title</h1>
    {props.children}
  </>
)

render(() => (
  <Router root={App}>
    <Route path="/" component={Home} />
    <Route path="/users" component={Users} />
  </Router>
), document.getElementById("root"));
```

**5. Create a CatchAll Route (404 page)**

A catchall route can be used for pages not found at any nested level of the router.
Using `*` and, optionally, a parameter name will retrieve the rest of the path.

```jsx
import { render } from "solid-js/web";
import { Router, Route } from "@solidjs/router";

import Home from "./pages/Home";
import Users from "./pages/Users";
import NotFound from "./pages/NotFound";

const App = props => (
  <>
    <h1>Site Title</h1>
    {props.children}
  </>
)

render(() => (
  <Router root={App}>
    <Route path="/" component={Home} />
    <Route path="/users" component={Users} />
    <Route path="*404" component={NotFound} />
  </Router>
), document.getElementById("root"));
```

**6. Create Links to Your Routes**

The [`<A>`](/solid-router/reference/components/a) component provides navigation to an application's routes.
Alternatively, you can use the [native anchor tag](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a). 
However, the `<A>` component provides additional functionality including some properties for CSS, `inactiveClass` and `activeClass`.

```jsx
import { render } from "solid-js/web";
import { Router, Route, A } from "@solidjs/router";

import Home from "./pages/Home";
import Users from "./pages/Users";
import NotFound from "./pages/NotFound";

const App = props => (
  <>
    <nav>
      <A href="/">Home</A>
      <A href="/users">Users</A>
    </nav>
    <h1>Site Title</h1>
    {props.children}
  </>
);

render(() => (
  <Router root={App}>
    <Route path="/" component={Home} />
    <Route path="/users" component={Users} />
    <Route path="*NotFound" component={NotFound} />
  </Router>
), document.getElementById("root"));
```

## Lazy-loading Route Components

The [`lazy`](/reference/component-apis/lazy) function postpones the loading of a component until it is navigated to.

```jsx
import { lazy } from "solid-js";
import { render } from "solid-js/web";
import { Router, Route } from "@solidjs/router";

const Users = lazy(() => import("./pages/Users"));
const Home = lazy(() => import("./pages/Home"));

const App = props => (
  <>
    <h1>Site Title</h1>
    {props.children}
  </>
)

render(() => (
  <Router root={App}>
    <Route path="/users" component={Users} />
    <Route path="/" component={Home} />
  </Router>
), document.getElementById("root"));
```

## Dynamic Routes

If a path is unknown ahead of time, you can treat part of the path as a flexible parameter.

```jsx
import { lazy } from "solid-js";
import { render } from "solid-js/web";
import { Router, Route } from "@solidjs/router";

const Users = lazy(() => import("./pages/Users"));
const User = lazy(() => import("./pages/User"));
const Home = lazy(() => import("./pages/Home"));

render(() => (
  <Router>
    <Route path="/users" component={Users} />
    <Route path="/users/:id" component={User} />
    <Route path="/" component={Home} />
  </Router>
 ), document.getElementById("root"));
```

The colon indicates that `id` can be any string, and as long as the URL fits that pattern,
the `<User>` component will show.


You can then access that `id` from within a route component with `useParams`.


**Note on Animation/Transitions**:
Routes that share the same path will be treated as the same route.
If you want to force re-render you can wrap your component in a keyed [`<Show>`](/reference/components/show) like:

```jsx
<Show when={params.something} keyed>
    <MyComponent>
</Show>


## Validating Routes

Each path parameter can be validated using a `MatchFilter`.
Instead of checking for the presence of a parameter, this allows for more complex routing descriptions.

```jsx
import { lazy } from "solid-js";
import { render } from "solid-js/web";
import { Router, Route } from "@solidjs/router";
import type { SegmentValidators } from "./types";

const User = lazy(() => import("./pages/User"));

const filters: MatchFilters = {
  parent: ["mom", "dad"], // allow enum values
  id: /^\d+$/, // only allow numbers
  withHtmlExtension: (v: string) => v.length > 5 && v.endsWith(".html"), // only `*.html` extensions wanted
};

render(() => (
  <Router>
    <Route
      path="/users/:parent/:id/:withHtmlExtension"
      component={User}
      matchFilters={filters}
    />
  </Router>
), document.getElementById("root"));
```

Here, the `matchFilters` prop as been added which provides a way to validate the `parent`, `id` and `withHtmlExtension` parameters against the filters defined in `filters`.
If the validation fails, the route will not match.

In this example:

- `/users/mom/123/contact.html` will match,
- `/users/dad/123/about.html` will match,
- `/users/aunt/123/contact.html` will **not** match as `:parent` is not 'mom' or 'dad',
- `/users/mom/me/contact.html` will **not** match as `:id` is not a number,
- `/users/dad/123/contact` will **not** match as `:withHtmlExtension` is missing `.html`.

### Optional Parameters

Parameters can be specified as optional by adding a question mark to the end of the parameter name:

```jsx
// Matches stories and stories/123 but not stories/123/comments
<Route path="/stories/:id?" component={Stories} />
```

### Wildcard Routes

To match any descendent routes within a given path, you can use the wildcard token (`*`).
This can be used to represent any value in that segment of the path.

```jsx
// Will match any path begnning with foo (eg. foo/, foo/a/, foo/a/b/c)
<Route path="foo/*" component={Foo} />
```

To expose the wildcard portion to the component as a parameter, you can name it:

```jsx
<Route path="foo/*any" component={Foo} />
```

Wildcard tokens **must** be the last part of the path; `foo/*any/bar` will not create any routes.

### Multiple Paths

The `Routes` component also supports defining multiple paths using an array.
This allows avoids a route rerendering when switching between two or more locations that it matches:

```jsx
// Navigating from "/login" to "/register" will not cause the component to re-render
<Route path={["login", "register"]} component={Login} />
```

## Nested Routes

Only leaf `<Route>` nodes (the innermost `<Route>` components) are given a route.



```jsx
<Route path="/users" component={Users}>
  <Route path="/:id" component={User} />
</Route>
```

The following two route definitions both match the same URL `/users:id` and render the same component:

```jsx
<Route path="/users/:id" component={User} />

<Route path="/users">
  <Route path="/:id" component={User} />
</Route>
```

If you want to make the parent its own route, you have to specify it separately.
These examples will work. They both will match `/users` and `/users/:id`.

```jsx
<Route path="/users" component={Users} />
<Route path="/users/:id" component={User} />

<Route path="/users">
  <Route path="/" component={Users} />
  <Route path="/:id" component={User} />
</Route>
```

You can also take advantage of nesting by using `props.children` passed to the route component.

```jsx
function PageWrapper(props) {
  return (
    <div>
      <h1> We love our users! </h1>
      {props.children}
      <A href="/">Back Home</A>
    </div>
  );
}

<Route path="/users" component={PageWrapper}>
  <Route path="/" component={Users} />
  <Route path="/:id" component={User} />
</Route>;
```

The routes are still configured the same, but now the route components will appear inside the parent component where the `props.children` is declared.


Routes can also be nested indefinitely.
This example will only render the route `/layer1/layer2`, which will be nested in 3 divs.

```jsx
<Route
  path="/"
  component={(props) =>
    <div>
      Outermost layer starts here {props.children}
    </div>
  }
>
  <Route
    path="layer1"
    component={(props) =>
      <div>
        Second layer {props.children}
      </div>
    }
  >
    <Route path="layer2"
      component={() => <div>Innermost layer</div>}>
    </Route>
  </Route>
</Route>
```

## Load Functions

Even with smart caches, you can still have waterfalls with both view logic and with lazy-loaded code.
With load functions, data fetching is started parallel to loading the route, so it can be used as soon as possible.
The load function is called when the Route is loaded, or eagerly when links are hovered.


As its only argument, the load function is passed an object that you can use to access route information:

```jsx
import { lazy } from "solid-js";
import { Route } from "@solidjs/router";

const User = lazy(() => import("./pages/users/[id].js"));

// load function
function loadUser({params, location}) {
  // do loading
}
```

The load function is then passed in the `<Route>` definition:

```jsx
<Route path="/users/:id" component={User} load={loadUser} />;
```

---

You can export load functions and data wrappers that correspond to routes from a dedicated `[route].data.js` or `[route].data.ts` file.
This pattern provides a way to import the data function without loading anything else.

```jsx
// src/pages/users/[id].data.js
import { cache } from "@solidjs/router";

export const getUser = cache(async (id) => {
  return (await fetch(`https://swapi.tech/api/people/${id}/`)).json();
}, "getUser");

export function loadUser({ params, location, intent }) {
  return getUser(params.id);
}
```

`loadUser` is passed an object which contains `params`, `location` and `intent`.

Please note that while it is best practice to write these files as `[id].data.js`, you can still write `route.data.js`.

The value of a load function is passed to the page component when called at any time other than "preload".
This means you can initialize the page, or use [Data APIs](/reference/solid-router/data-apis/create-async).

<Callout>
To prevent a fetch from happening more than once, or to trigger a refetch, you can use the [`cache` function](/reference/solid-router/data-apis/cache).
</Callout>

```jsx title="index.jsx"
import { lazy } from "solid-js";
import { render } from "solid-js/web";
import { Router, Route } from "@solidjs/router";
import { loadUser } from "./pages/users/[id].data.js";

const Home = lazy(() => import('./pages/Home'))
const User = lazy(() => import('./pages/users/[id]'))

render(() => (
  <Router>
    <Route path="/" component={Home} />
    <Route
      path="/users/:id"
      component={User}
      load={loadUser}
    />
  </Router>
), document.getElementById("root"));
```

`[id].jsx` contains the component that gets rendered.
When you wrap the function within [`createAsync`](/solid-router/reference/data-apis/create-async) with the imported function, it will yield [a signal](/routes/concepts/signals) once the anticipated promise resolves.


```jsx
// [id].jsx
import { createAsync } from "@solidjs/router";
import { getUser } from "./[id].data";

export default function Users(props) {
  console.log('Users.props', props)
  const user = createAsync(() => getUser(props.params.id));
  return (
    <>
      <h1>User</h1>
      <div>
        <pre>{JSON.stringify(user(), null, 2)}</pre>
      </div>
    </>
  )
}
```



## Config Based Routing

JSX is not required when defining routes in Solid.
Instead, you can pass an array of route definitions:

```jsx
import { lazy } from "solid-js";
import { render } from "solid-js/web";
import { Router } from "@solidjs/router";

const routes = [
  {
    path: "/users",
    component: lazy(() => import("/pages/users.js")),
  },
  {
    path: "/users/:id",
    component: lazy(() => import("/pages/users/[id].js")),
    children: [
      {
        path: "/",
        component: lazy(() => import("/pages/users/[id]/index.js")),
      },
      {
        path: "/settings",
        component: lazy(() => import("/pages/users/[id]/settings.js")),
      },
      {
        path: "/*all",
        component: lazy(() => import("/pages/users/[id]/[...all].js")),
      },
    ],
  },
  {
    path: "/",
    component: lazy(() => import("/pages/index.js")),
  },
  {
    path: "/*all",
    component: lazy(() => import("/pages/[...all].js")),
  },
];

render(() =>
  <Router>{routes}</Router>,
  document.getElementById("root")
);
```

Additionally, a single route definition object for a single route can be passed:

```jsx
import { lazy } from "solid-js";
import { render } from "solid-js/web";
import { Router } from "@solidjs/router";

const route = {
  path: "/",
  component: lazy(() => import("/pages/index.js"))
};

render(() => <Router>{route}</Router>, document.getElementById("root"));
```

## Alternative Routers

### Hash Mode Router

By default, Solid Router uses `location.pathname` as the route path.
If you need, you can switch to hash mode by using `<HashRouter>`.

```jsx
import { HashRouter } from "@solidjs/router";

<HashRouter />;
```

### Memory Mode Router

The memory mode router can also be used, if desired, for testing purposes.

```jsx
import { MemoryRouter } from "@solidjs/router";

<MemoryRouter />;
```

### SSR Routing

For SSR, the static router can be use directly or, alternatively, the browser router will defaults to it on the server by passing in the URL.

```jsx
import { isServer } from "solid-js/web";
import { Router } from "@solidjs/router";

<Router url={isServer ? req.url : ""} />;
```

## SPAs in Deployed Environments

When deploying applications dependent on a client-side router without Server Side Rendering, it is essential to manage redirects to the index page. 
This prevents the CDN or Hosting service from returning 'not found' errors for pages that do not exist.


Each provider has a different way of doing this.
For example, on Netlify you create a `_redirects` file that contains:

```
/*   /index.html   200
```

On Vercel you add a rewrites section to your `vercel.json`:

```json

{
  "rewrites": [
    {
      "source": "/(.*)",
      "destination": "/index.html"
    }
  ]
}
```

