---
title: Derived signals
order: 1
use_cases: >-
  computed values, reactive calculations, dependent state, always, any solid
  project, data transformations
tags:
  - reactivity
  - computed
  - derived
  - calculations
  - dependencies
  - always
version: '1.0'
---

Derived signals are functions that rely on one or more [signals](/concepts/signals) to produce a value.

These functions are not executed immediately, but instead are only called when the values they rely on are changed.
When the underlying signal is changed, the function will be called again to produce a new value.

```js
const double = () => count() * 2;
```

In the above example, the `double` function relies on the `count` signal to produce a value.
When the `count` signal is changed, the `double` function will be called again to produce a new value.

Similarly you can create a derived signal that relies on a store value because stores use signals under the hood.
To learn more about how stores work, [you can visit the stores section](/concepts/stores).

```js
const fullName = () => store.firstName + ' ' + store.lastName;
```

These dependent functions gain reactivity from the signal they access, ensuring that changes in the underlying data propagate throughout your application. 
It is important to note that these functions do not store a value themselves; instead, they can update any effects or components that depend on them. 
If included within a component's body, these derived signals will trigger an update when necessary.

While you can create derived values in this manner, Solid created the [`createMemo`](/reference/basic-reactivity/create-memo) primitive.
To dive deeper into how memos work, [check out the memos section](/concepts/derived-values/memos).
