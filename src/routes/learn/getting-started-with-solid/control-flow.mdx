import { FrameworkAside } from "../../../components/FrameworkAside";
import { Tabs, Tab } from "../../../components/Tabs";
import { BasicBookshelfShow } from "../components/BasicBookshelfShow";

<title>Conditional UI Display</title>

# Conditional User Interface Display

In dynamic front-end applications, we typically want to show different user interfaces when the application is in different states. An example of this is displaying a welcome message to either a guest or an authenticated user.

For a guest, we might want to display a generic welcome message alongside a sign-in form:

```tsx
<div>Welcome to the application. Please sign in to continue.</div>
<SignInForm />
```

For an authenticated user, we might want to greet them by their name and provide them with their custom dashboard:

```tsx
<div>Welcome back, Jessica!</div>
<Dashboard />
```

## Conditionally showing content

In Solid, we can use the `<Show />` component to conditionally show content. The `<Show />` component takes a `when` prop and an optional `fallback` prop.

- When the `when` prop is `true`, the JSX inside `<Show />` is displayed
- When the `when` prop is `false`, the JSX inside `fallback` is displayed (if provided)

The following example shows how we would use the `<Show />` component to conditionally display a sign-in or dashboard page:

<Tabs files={["Home.tsx"]} selected="Home.tsx">

```tsx
import { Show } from "solid-js";

interface IHomeProps {
  isLoggedIn: boolean;
  firstName: string;
}

function Home(props: IHomeProps) {
  return (
    <Show
      when={props.isLoggedin}
      fallback={
        <>
          <div>Welcome to the application. Please sign in to continue.</div>
          <SignInForm />
        </>
      }
    >
      <div>Welcome back, {props.firstName}!</div>
      <Dashboard />
    </Show>
  );
}
```

</Tabs>

When `props.isLoggedIn` is `true`, we welcome the user back and show the `<Dashboard />`. When `props.isLoggedIn` is `false`, we display the `fallback` content, which is our generic greeting message and the `<SignInForm />`.

<FrameworkAside framework="react">
In React, it's a common pattern to handle control flow by returning early from a component function. For example, you might have done the following to accomplish our conditional authentication display:

```jsx
function Home(props) {
  if (props.isLoggedIn) {
    return (
      <>
        <div>Welcome back, {props.firstName}!</div>
        <Dashboard />
      </>
    );
  }

  return (
    <>
      <div>Welcome to the application. Please sign in to continue.</div>
      <SignInForm />
    </>
  );
}
```

However, **this won't work in Solid!**

In the [Building UI with Components](../building-ui-with-components) section of this tutorial, we noted that component functions _run only once_ in Solid. This means the JSX returned from that initial function return is the only JSX that will ever be returned from the function.

In Solid, if we want to conditionally display JSX in a component, we need that condition to reside within the returned JSX. While this takes some adjustment when coming from React, we have found that the fine-grained control afforded by Solid's reactive system is worth the trade-off.

</FrameworkAside>

## Iterating over data with `<For />`

User interfaces often require us to display lists of data. These lists can typically be any length, and therefore we can't just hardcode each element. Instead, Solid gives us the `<For />` component. If you have been coding along with the Bookshelf app example, you'll notice we already had to use this component.

The `<For />` component takes the array you want to loop over in the `each` prop:

```jsx
const books = ["Book 1", "Book 2"];

<For each={books}>...</For>;
```

Inside the `<For />` component, you use a _callback function_ to loop over the items. In this case, we create a new list item `<li>` for each book in our `books` array:

```jsx
const books = ["Book 1", "Book 2"];

<For each={books}>
  {(book) => {
    return <li>{book}</li>;
  }}
</For>;
```

<FrameworkAside framework="react">

In React, you iterate over arrays in JSX using the array `map` method:

```jsx
<>
  {books.map((book) => {
    return <li key={book}>{book}</li>;
  })}
</>
```

This would actually work in Solid, but in not optimal. You can think of `<For />` as an optimized version of `map`. When using `<For /> `, Solid is able to intelligently determine which array elements to update without you having to provide a `key`.

</FrameworkAside>

## Revisiting the bookshelf

In the [Adding Interactivity with State](../adding-interactivity-with-state) section of this tutorial, we found ourselves already needing the `<For />` component. This allowed us to iterate over any number of books in on our bookshelf:

<Tabs files={["App.tsx", "BookList.tsx", "AddBook.tsx"]} selected="BookList.tsx">
  <Tab name="App.tsx">

```tsx
import { render } from "solid-js/web";
import { createSignal } from "solid-js";
import { BookList } from "./BookList";
import { AddBook } from "./AddBook";

export type Book = {
  title: string;
  author: string;
};

const initialBooks: Book[] = [
  { title: "Code Complete", author: "Steve McConnell" },
  { title: "The Hobbit", author: "J.R.R. Tolkien" },
];

interface IBookshelfProps {
  name: string;
}

function Bookshelf(props: IBookshelfProps) {
  const [books, setBooks] = createSignal(initialBooks);

  return (
    <div>
      <h1>{props.name}'s Bookshelf</h1>
      <BookList books={books()} />
      <AddBook setBooks={setBooks} />
    </div>
  );
}

const root = document.getElementById("root");

if (root) {
  render(() => <Bookshelf name="Solid" />, root);
}
```

  </Tab>
  <Tab name="BookList.tsx">

```tsx
import { Book } from "./App";

interface IBookListProps {
  books: Book[];
}

export function BookList(props: IBookListProps) {
  const totalBooks = () => props.books.length;

  return (
    <>
      <h2>Total books ({totalBooks()})</h2>
      <ul>
        <For each={props.books}>
          {(book) => {
            return (
              <li>
                {book.title}{" "}
                <span style={{ "font-style": "italic" }}>({book.author})</span>
              </li>
            );
          }}
        </For>
      </ul>
    </>
  );
}
```

  </Tab>
  <Tab name="AddBook.tsx">

```tsx
import { createSignal, Setter, JSX } from "solid-js";
import { Book } from "./App.tsx";

interface IAddBookProps {
  setBooks: Setter<Book[]>;
}

const emptyBook: Book = { title: "", author: "" };

function AddBook(props: IAddBookProps) {
  const [newBook, setNewBook] = createSignal(emptyBook);

  const addBook: JSX.EventHandler<HTMLButtonElement, MouseEvent> = (event) => {
    event.preventDefault();
    props.setBooks((books) => [...books, newBook()]);
    setNewBook(emptyBook);
  };

  return (
    <form>
      <div>
        <label for="title">Book name</label>
        <input
          id="title"
          value={newBook().title}
          onInput={(e) => {
            setNewBook({ ...newBook(), title: e.currentTarget.value });
          }}
        />
      </div>
      <div>
        <label for="author">Author</label>
        <input
          id="author"
          value={newBook().author}
          onInput={(e) => {
            setNewBook({ ...newBook(), author: e.currentTarget.value });
          }}
        />
      </div>
      <button type="submit" onClick={addBook}>
        Add book
      </button>
    </form>
  );
}
```

  </Tab>
</Tabs>

Let's now use the `<Show />` component. We will only show our `AddBook` form if the user wants to add a book.

We will create a boolean signal in the `Bookshelf` component that tracks whether or not the form is open and add buttons to open and close the form. We will use the `<Show />` component to conditionally display the form.

<Tabs files={["App.tsx", "BookList.tsx", "AddBook.tsx"]} selected="App.tsx">
  <Tab name="App.tsx">

```tsx
import { render } from "solid-js/web";
import { createSignal, Show } from "solid-js";
import { BookList } from "./BookList";
import { AddBook } from "./AddBook";

export type Book = {
  title: string;
  author: string;
};

const initialBooks: Book[] = [
  { title: "Code Complete", author: "Steve McConnell" },
  { title: "The Hobbit", author: "J.R.R. Tolkien" },
];

interface IBookshelfProps {
  name: string;
}

function Bookshelf(props: IBookshelfProps) {
  const [books, setBooks] = createSignal(initialBooks);
  const [showForm, setShowForm] = createSignal(false);

  toggleForm = () => setShowForm(!showForm());

  return (
    <div>
      <h1>{props.name}'s Bookshelf</h1>
      <BookList books={books()} />
      <Show
        when={showForm()}
        fallback={<button onClick={toggleForm}>Add a book</button>}
      >
        <AddBook setBooks={setBooks} />
        <button onClick={toggleForm}>Finished adding books</button>
      </Show>
    </div>
  );
}

const root = document.getElementById("root");

if (root) {
  render(() => <Bookshelf name="Solid" />, root);
}
```

  </Tab>
  <Tab name="BookList.tsx">

```tsx
import { Book } from "./App";

interface IBookListProps {
  books: Book[];
}

export function BookList(props: IBookListProps) {
  const totalBooks = () => props.books.length;

  return (
    <>
      <h2>Total books ({totalBooks()})</h2>
      <ul>
        <For each={props.books}>
          {(book) => {
            return (
              <li>
                {book.title}{" "}
                <span style={{ "font-style": "italic" }}>({book.author})</span>
              </li>
            );
          }}
        </For>
      </ul>
    </>
  );
}
```

  </Tab>
  <Tab name="AddBook.tsx">

```tsx
import { createSignal, Setter, JSX } from "solid-js";
import { Book } from "./App.tsx";

interface IAddBookProps {
  setBooks: Setter<Book[]>;
}

const emptyBook: Book = { title: "", author: "" };

function AddBook(props: IAddBookProps) {
  const [newBook, setNewBook] = createSignal(emptyBook);

  const addBook: JSX.EventHandler<HTMLButtonElement, MouseEvent> = (event) => {
    event.preventDefault();
    props.setBooks((books) => [...books, newBook()]);
    setNewBook(emptyBook);
  };

  return (
    <form>
      <div>
        <label for="title">Book name</label>
        <input
          id="title"
          value={newBook().title}
          onInput={(e) => {
            setNewBook({ ...newBook(), title: e.currentTarget.value });
          }}
        />
      </div>
      <div>
        <label for="author">Author</label>
        <input
          id="author"
          value={newBook().author}
          onInput={(e) => {
            setNewBook({ ...newBook(), author: e.currentTarget.value });
          }}
        />
      </div>
      <button type="submit" onClick={addBook}>
        Add book
      </button>
    </form>
  );
}
```

  </Tab>
</Tabs>

When `showForm()` is `true`, the app displays the `<AddBook />` form and a button that allows us to hide the form again. When `showForm()` is `false`, the `fallback` component is displayed&mdash;a button to show the `<AddBook />` form.

<BasicBookshelfShow name="Solid" />
