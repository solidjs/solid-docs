---
title: "Defining routes"
---


## Component routing

To define routes using JSX, the [`Route`](/solid-router/reference/components/route) component is used to define a path and the component to render when the user navigates to that path.

1. Add each route to a [`<Router>`](/solid-router/reference/components/router) using the `Route` component.
   A path as well as an element or component to render must be provided for when the user navigates to the indicated path.

```jsx
import { render } from "solid-js/web";
import { Router, Route } from "@solidjs/router";

import Home from "./pages/Home";
import Users from "./pages/Users";

render(
	() => (
		<Router>
			<Route path="/users" component={Users} />
			<Route path="/" component={Home} />
		</Router>
	),
	document.getElementById("app")
);
```

2. Provide a root level layout (optional)

A root level layout will always be present and will not update on page change.
This is the ideal place for any top level navigation and [Context Providers](/concepts/context#consuming-context).

```jsx
import { render } from "solid-js/web";
import { Router, Route } from "@solidjs/router";

import Home from "./pages/Home";
import Users from "./pages/Users";
import Nav from "./components/Nav";

const App = (props) => (
	<>
		<h1>Site Title</h1>
		<Nav />
		{props.children}
	</>
);

render(
	() => (
		<Router root={App}>
			<Route path="/users" component={Users} />
			<Route path="/" component={Home} />
		</Router>
	),
	document.getElementById("app")
);
```

3. Create a CatchAll Route (404 page)

When pages are *not* found at any nested level, providing a catchall, or 404 page, provides a fallback option to display to the user.
The asterisk (`*`) is used, along with optionally specifying a parameter's name, to access the remaining portion of the path.

```jsx
import { render } from "solid-js/web";
import { Router, Route } from "@solidjs/router";

import Home from "./pages/Home";
import Users from "./pages/Users";
import NotFound from "./pages/404";

const App = (props) => (
	<>
		<h1>My Site with lots of pages</h1>
		{props.children}
	</>
);

render(
	() => (
		<Router root={App}>
			<Route path="/users" component={Users} />
			<Route path="/" component={Home} />
			<Route path="*404" component={NotFound} />
		</Router>
	),
	document.getElementById("app")
);
```

Once the `Router` component is set up with the desired routes, the specified components will render when the user navigates to the corresponding paths.
For example, when the user navigates to `/users`, the `Users` component will be rendered:

4. Lazy-load route components

This way, the `Users` and `Home` components will only be loaded when navigating to `/users` or `/`, respectively.

```jsx
import { lazy } from "solid-js";
import { render } from "solid-js/web";
import { Router, Route } from "@solidjs/router";

const Users = lazy(() => import("./pages/Users"));
const Home = lazy(() => import("./pages/Home"));

const App = (props) => (
	<>
		<h1>My Site with lots of pages</h1>
		{props.children}
	</>
);

render(
	() => (
		<Router root={App}>
			<Route path="/users" component={Users} />
			<Route path="/" component={Home} />
		</Router>
	),
	document.getElementById("app")
);
```

### Configuration-based routing

To improve the performance of your application, you can use the `lazy` function from Solid to load components only when they are needed.
This is especially useful for large components that are not needed immediately when the application loads:

```jsx
const ComplexPage = lazy(() => import("./pages/ComplexPage"));
```

The `lazy` function takes a function that returns a promise that resolves to the component.
When the component is needed, the promise will be resolved and the component will be loaded.
When using configuration-based routing, you can use the `lazy` function to load components lazily, to improve the performance of your application:

```jsx
const routes = [
	{
		path: "/",
		component: lazy(() => import("./pages/Home")),
	},
	{
		path: "/users",
		component: lazy(() => import("./pages/Users")),
	},
];
```
