---
title: Event Handlers
order: 3
---

Event handlers are functions that are called in response to specific events
occurring in the browser, such as when a user clicks or taps on an element.

Solid provides two ways to add event listeners to the browser. Using the
[`on:__`](/reference/jsx-attributes/on-and-oncapture) form, which will add an
event listener to the `element`, known as a _Native Event_. Using the
[`on__`](/reference/jsx-attributes/on_) form, which will add an event listener
to the `document` and dispatch it to the `element`, known as a _Delegated
Event_.

The reasons for the two forms are performance and design. Delegated Events flow
through the _Component Tree_, and save some resources performing better on
commonly used events, while Native Events flow through the _DOM Tree_ and allow
more control of the behavior of the event. Check
[event delegation considerations](#event-delegation-considerations) for
documentation on some differences between them.

## Using events

To add an event handler, prefix the event name with either `on` or `on:`, and
assign it to the function that should be called whenever the event is
dispatched.

```tsx
// delegated event
<button onClick={handleClick}>Click me</button>

// native event
<div on:scroll={handleScroll}>... very long text ...</div>
```

<Callout type="info" title="Case Sensitivity">
  Delegated events are case-insensitive, and Native events are case-sensitive.
</Callout>

For example, when using delegated event handlers in Solid, they can be written
using camelCase or all lowercase.

```tsx
<button onclick={handleClick}>Click me</button>
```

For any other events, perhaps custom events, or ones you wish not to be
delegated, the attribute adds an event listener as-is. This makes the event
listener case sensitive.

```tsx
<button on:Custom-Event={handleClick}>Click me</button>
```

For typing `Custom-Event` the TypeScript page has a section about
[Event Handlers Types](/configuration/typescript#event-handling).

## Binding events

In Solid, as an optimization, event handlers can be bound by passing an array as
the event handler, instead of a function. The second item of the array, in this
case `data`, is supplied as the handler's first argument.

```tsx
const handler = (data, event) => {
  console.log("Data:", data, "Event:", event);
};

<button onClick={[handler, "Hello!"]}>Click Me</button>;
```

In this example, the string `'Hello!'` is passed as the `data` parameter when
the button is clicked.

By binding events in this way, Solid avoids the overhead of using the
JavaScript's
[bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind)
method and an aditional closure.

### Dynamic Handlers

A handler won't form part of the reactive system. For example passing the
handler as a signal won't have any effect on the handler if the signal changes.
The reason for this is that attaching and detaching listeners is a costly
process. In other words, Events are never rebound and the bindings are not
reactive.

However, since event handlers are called like any other regular function, if
necessary you can write your handlers to call a reactive source.

In the following example, `handleClick` represents a prop that could dynamically
change its value to any function you wish, so there's no inherent need for them
to be reactive.

```tsx
<div onClick={() => props.handleClick?.()} />
```

## Event delegation

Instead of attaching event listeners to every individual element, Solid uses
(via the regular [`on__`](/reference/jsx-attributes/on_) form), what's known as
_synthetic event delegation_. This means that event listeners are attached to
the `document` element, and dispatched to the relevant elements as the event
bubbles up.

By keeping the number of event listeners to a minimum, events can be captured
more effectively. This is especially useful when working with a large number of
elements, such as in a table or list.

Supported events such as `click`, `input` and `keydown` are just a few examples
that are optimized in this way. To view the full list see the
[references below](#delegated-events).

If you need to attach an event listener to an element that is not supported by
Solid's event delegation, such a custom event in a
[Custom Element](https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_custom_elements),
you can use the [`on:__`](/reference/jsx-attributes/on-and-oncapture) form.

```tsx
<div on:customEvent={handleCustomEvent} />
```

### Event delegation considerations

While delegated events provide some performance enhancements, it comes with some
tradeoffs that should be considered.

 <Callout type="info" title="Design">

Event delegation is designed for event propagation through the JSX Tree, rather
than the DOM Tree.

</Callout>

This differs from the acquired expectations one may have over how events work
and flow.

Here is a list of peculiarities to keep in mind:

1.  Delegated event listeners are added to the `document` once per event type.
    When the element/component that added it is removed, it's handler function
    will no longer be called, but the delegated event listener will still be
    present on the `document`. Considering the following example, a `div`
    listening for `mousemove`. `mousemove` will still be dispatched to the
    `document` even if the `div` is disposed.

```tsx
<div onMouseMove={handleCustomEvent} />
```

<Callout type="tip" title="Ocassional Events">
Consider using Native Events instead of Delegated Events for rare or ocassional events that happen on special circumstances and won't benefit from the performance improvements of event delegation.

```tsx
<div on:mousemove={handleCustomEvent} />
```

</Callout>

2. When in need to `stopPropagation` use a Native Event instead.
   `event.stopPropagation()` won't work as expected as the event is attached to
   the `document` instead of to the `element`.

   Considering the following example. Using a Native Event would have stopped
   the event from reaching the `div native` handler. This is not the case for
   Delegated Events.

```tsx
onMount(() => {
  ref.addEventListener("click", () => {
    console.log("div native");
  });
});
<div ref={ref}>
  <button
    onClick={(event) => {
      event.stopPropagation();
      console.log("button");
    }}
  >
    button
  </button>
</div>;
```

```shellsession title="Console output"
// Button clicked
div native
button
```

Here is a
[Solid Playground Example](https://playground.solidjs.com/anonymous/c5346f84-01e4-4080-8ace-4443ffd0bb10)

This can be solved by switching the `button` event to use a Native Event as
follows:

```tsx ins="on:click"
// ...
<button
  on:click={(event) => {
    event.stopPropagation();
    console.log("button");
  }}
>
  button
</button>
// ...
```

```shellsession title="Console output"
// Button clicked
button
```

Here is a
[Solid Playground Example](https://playground.solidjs.com/anonymous/9e2deddc-2e83-4ac2-8ee0-49c7c3a45d11)

3. Even when the following `Portal` gets attached to the `body`, the event on
   the `input` element will still propagate up to the `container`. Because
   Portals propagate events following the _Component Tree_, not the _DOM Tree_.
   This provides the benefit that makes Portals easier to use.

```tsx
<div class="container" onInput={() => console.log("portal key press")}>
  <Portal mount={document.body}>
    <input onInput={() => console.log("input key press")} />
  </Portal>
</div>
```

<Callout type="info" title="onInput / onChange">

`onChange` and `onInput` work according to their native behavior. `onInput` will
fire immediately after the value has changed; for `<input>` fields, `onChange`
will only fire after the field loses focus.

</Callout>

## Delegated Events

You can also view this list in our
[source code](https://github.com/ryansolid/dom-expressions/blob/main/packages/dom-expressions/src/constants.js)
(see DelegatedEvents).

- [`beforeinput`](https://developer.mozilla.org/en-US/docs/Web/API/Element/beforeinput_event)
- [`click`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click)
- [`dblclick`](https://developer.mozilla.org/en-US/docs/Web/API/Element/dblclick_event)
- [`contextmenu`](https://developer.mozilla.org/en-US/docs/Web/API/Element/contextmenu_event)
- [`focusin`](https://developer.mozilla.org/en-US/docs/Web/API/Element/focusin_event)
- [`focusout`](https://developer.mozilla.org/en-US/docs/Web/API/Element/focusout_event)
- [`input`](https://developer.mozilla.org/en-US/docs/Web/API/Element/input_event)
- [`keydown`](https://developer.mozilla.org/en-US/docs/Web/API/Element/keydown_event)
- [`keyup`](https://developer.mozilla.org/en-US/docs/Web/API/Element/keyup_event)
- [`mousedown`](https://developer.mozilla.org/en-US/docs/Web/API/Element/mousedown_event)
- [`mousemove`](https://developer.mozilla.org/en-US/docs/Web/API/Element/mousemove_event)
- [`mouseout`](https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseout_event)
- [`mouseover`](https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseover_event)
- [`mouseup`](https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseup_event)
- [`pointerdown`](https://developer.mozilla.org/en-US/docs/Web/API/Element/pointerdown_event)
- [`pointermove`](https://developer.mozilla.org/en-US/docs/Web/API/Element/pointermove_event)
- [`pointerout`](https://developer.mozilla.org/en-US/docs/Web/API/Element/pointerout_event)
- [`pointerover`](https://developer.mozilla.org/en-US/docs/Web/API/Element/pointerover_event)
- [`pointerup`](https://developer.mozilla.org/en-US/docs/Web/API/Element/pointerup_event)
- [`touchend`](https://developer.mozilla.org/en-US/docs/Web/API/Element/touchend_event)
- [`touchmove`](https://developer.mozilla.org/en-US/docs/Web/API/Element/touchmove_event)
- [`touchstart`](https://developer.mozilla.org/en-US/docs/Web/API/Element/touchstart_event)
