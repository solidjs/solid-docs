---
title: createResource
---

Creates a reactive resource that manages asynchronous data fetching and loading states, automatically tracking dependencies and providing a simple interface for reading, refreshing, and error handling.

## Import

```typescript
import { createResource } from "solid-js";
```

## Type Signature

```typescript
// Without source
function createResource<T, R = unknown>(
  fetcher: ResourceFetcher<true, T, R>,
  options?: ResourceOptions<T>
): ResourceReturn<T, R>

// With source
function createResource<T, S, R = unknown>(
  source: ResourceSource<S>,
  fetcher: ResourceFetcher<S, T, R>,
  options?: ResourceOptions<T, S>
): ResourceReturn<T, R>
```

### Related Types

```typescript
type ResourceReturn<T, R = unknown> = [Resource<T>, ResourceActions<T, R>]

type Resource<T> = {
  (): T | undefined
  state: "unresolved" | "pending" | "ready" | "refreshing" | "errored"
  loading: boolean
  error: any
  latest: T | undefined
}

type ResourceActions<T, R = unknown> = {
  mutate: (value: T | undefined) => T | undefined
  refetch: (info?: R) => Promise<T> | T | undefined
}

type ResourceSource<S> = S | false | null | undefined | (() => S | false | null | undefined)

type ResourceFetcher<S, T, R = unknown> = (
  source: S,
  info: { value: T | undefined; refetching: R | boolean }
) => T | Promise<T>

interface ResourceOptions<T, S = unknown> {
  initialValue?: T
  name?: string
  deferStream?: boolean
  ssrLoadFrom?: "initial" | "server"
  storage?: (init: T | undefined) => [Accessor<T | undefined>, Setter<T | undefined>]
  onHydrated?: (k: S | undefined, info: { value: T | undefined }) => void
}
```

## Parameters

### `source`
- **Type:** `ResourceSource<S>`
- **Default:** `undefined`

Reactive data source whose non-nullish and non-false values are passed to the fetcher. 
When the source changes, the fetcher is automatically re-run.

### `fetcher`
- **Type:** `ResourceFetcher<S, T, R>`

Function that receives the source value (or `true` if no source), the current resource info, and returns a value or Promise.

### `options`
- **Type:** `ResourceOptions<T, S>`
- **Default:** `{}`

Configuration options for the resource.

## Options

### `initialValue`
- **Type:** `T`
- **Default:** `undefined`

Initial value for the resource. 
When provided, the resource starts in "ready" state and the type excludes `undefined`.

### `name`
- **Type:** `string`
- **Default:** `undefined`

A name for debugging purposes in development mode.

### `deferStream`
- **Type:** `boolean`
- **Default:** `false`

Controls streaming behavior during server-side rendering.

### `ssrLoadFrom`
- **Type:** `"initial" | "server"`
- **Default:** `"server"`

Determines how the resource loads during SSR hydration.

### `storage`
- **Type:** `(init: T | undefined) => [Accessor<T | undefined>, Setter<T | undefined>]`
- **Default:** `createSignal`

Custom storage function for the resource value, useful for persistence or custom state management.

### `onHydrated`
- **Type:** `(k: S | undefined, info: { value: T | undefined }) => void`
- **Default:** `undefined`

Callback fired when the resource hydrates on the client side.

## Return Value

- **Type:** `[Resource<T>, ResourceActions<T, R>]`

Returns a tuple containing the resource accessor and resource actions.

### `Resource` 

```typescript
type Resource<T> = {
  (): T | undefined
  state: "unresolved" | "pending" | "ready" | "refreshing" | "errored"
  loading: boolean
  error: any
  latest: T | undefined
}
```

- `state`: Current state of the resource.
- `loading`: Indicates if the resource is currently loading.
- `error`: Error information if the resource failed to load.
- `latest`: The latest value of the resource.


### `ResourceActions`

```typescript
type ResourceActions<T, R = unknown> = {
  mutate: (value: T | undefined) => T | undefined
  refetch: (info?: R) => Promise<T> | T | undefined
}
```

- `mutate`: Function to Manually overwrite the resource value without calling the fetcher.
- `refetch`: Function to re-run the fetcher without changing the source.
If a parameter is provided to `refetch`, it will be passed to the fetcher's `refetching` property.

## Usage

### Basic Usage

```typescript
Basic Usage

const [data] = createResource(async () => {
  const response = await fetch('/api/data');
  return response.json();
});

// Access data
console.log(data()); // undefined initially, then fetched data
console.log(data.loading); // true during fetch
console.log(data.state); // "pending" → "ready"
```

### With Source

```typescript
const [userId, setUserId] = createSignal(1);

const [user] = createResource(userId, async (id) => {
  const response = await fetch(`/api/users/${id}`);
  return response.json();
});

// Automatically refetches when userId changes
setUserId(2);
```

### With Actions

```typescript
const [posts, { refetch, mutate }] = createResource(fetchPosts);

// Manual refetch
await refetch();

// Optimistic update
mutate(posts => [...posts, newPost]);
```

### Error handling

```typescript
const [data] = createResource(async () => {
  const response = await fetch('/api/data');
  if (!response.ok) throw new Error('Failed to fetch');
  return response.json();
});

// In JSX
<ErrorBoundary fallback={<div>Error loading data</div>}>
  <div>{data()?.title}</div>
</ErrorBoundary>
```

### With Initial Value

```typescript
const [user] = createResource(
  () => fetchUser(),
  { initialValue: { name: 'Loading...', id: 0 } }
);

// user() is never undefined
console.log(user().name); // "Loading..." initially
```

### Conditional Fetching

```typescript
const [isEnabled, setIsEnabled] = createSignal(false);

const [data] = createResource(
  () => isEnabled() && userId(), // Only fetches when enabled and userId exists
  async (id) => fetchUserData(id)
);
```

## Details

Resources provide a reactive pattern for handling asynchronous data that integrates seamlessly with SolidJS's reactivity system and Suspense boundaries. 
Unlike signals, resources are specifically designed for async operations and provide built-in loading states, error handling, and refetching capabilities.

### State Management

State follows a predictable lifecycle: `"unresolved" → "pending" → "ready"/"errored"`. 
During refetching, the state transitions to `"refreshing"` while maintaining the previous value accessible via the latest property. 
This prevents UI flickering during updates.

In version v.1.5.0, resources gained the ability to cover a more detailed view of the Resource state, beyond `loading` and `error` states. 
This includes distinct states for initial loading, successful fetches, refetching, and errors:

| State | Description | Loading | Error | Latest |
| ------ | ----------- | ------- | ----- | ------ |
| `unresolved` | Initial state, not yet fetched | `false` | `undefined` | `undefined` |
| `pending` | Fetching in progress | `true` | `undefined` | `undefined` |
| `ready` | Successfully fetched | `false` | `undefined` | `T` |
| `refreshing` | Refetching while keeping previous value | `true` | `undefined` | `T` |
| `errored` | Fetching failed | `false` | `any` | `undefined` |

### Source Reactivity

Source automatically triggers refetching when the source value changes.
The fetcher only runs when the source is truthy (not `null`, `undefined`, or `false`), allowing for conditional fetching patterns.
Sources can be static values, reactive accessors, or computed values.

### Refetching Behavior

Refetching lets you manually trigger the fetcher using the `refetch` action, optionally passing extra parameters for more control over the request. 
The `mutate` action allows you to optimistically update the resource value locally, without making a network request.

### Suspense Integration

Resources automatically suspend the nearest `<Suspense>` boundary while loading, allowing you to declaratively show fallback UI until data is ready. 
When a resource is pending or refreshing, components reading its value will suspend, and the fallback of the closest Suspense boundary will be displayed. 
If an error is thrown, the nearest `<ErrorBoundary>` will catch it. 

### SSR and Hydration

Solid's resources are designed for seamless server-side rendering (SSR) and hydration. 
During SSR, resource data is serialized and streamed to the client, enabling fast initial page loads and smooth transitions. 
The `ssrLoadFrom` option lets you control how the resource behaves after hydration:

- `"server"` (default): The client uses the value fetched on the server during hydration, providing immediate access to data without additional fetches.
- `"initial"`: The client re-fetches the data after hydration, allowing for dynamic updates but potentially leading to a loading state on the client.

### Error Handling

- Resources provide built-in error handling capabilities, allowing you to easily manage errors that occur during data fetching.
- Accessing the resource value when in error state re-throws the error, triggering error boundaries. The `ErrorBoundary` component can be used to catch errors and display fallback UI.

### Performance Characteristics

Performance is enhanced by automatically deduplicating concurrent fetches and leveraging Solid's fine-grained reactivity and batching mechanisms. 
During server-side rendering, resources can stream data for faster initial loads and improved user experience.


