---
title: "Overview"
order: 1
---

[TODO: Review]

:::note
While this guide can be helpful for understanding reactive systems, it does use some Solid-specific terminology and concepts.
:::

Reactivity is what powers the interactivity of Solid apps.
This programming paradigm refers to a system's ability to respond to changes in data, or state, automatically and efficiently.
Solid is built with reactivity at the core of its design, assisting applications with staying up-to-date with its underlying data.

## The Importance of Reactivity

Reactivity is what keeps the user interface (UI) in sync with the underlying application state. 
When the state changes, the UI is automatically updated, reducing the need for manual updates.

In addition, reactivity enables real-time updates, allowing applications to reflect changes instantly without requiring a full page refresh. 
This helps with creating more responsive and interactive user experiences. 

As an example, when building a Counter, you can use the reactive primitives provided by Solid to create a counter. 
Once the counter is set up, whenever the count changes, the UI will automatically update to reflect the new count:

```tsx
function Counter() {
  const [count, setCount] = createSignal<number>(0);
  const increment = () => setCount((prev) => prev + 1);

  return (
    <div>
      <span>Count: {count()}</span>{" "}
      {/* Only `count()` is updated when the button is clicked. */}
      <button type="button" onClick={increment}>
        Increment
      </button>
    </div>
  );
}
```

## Reactive Principles

### Signals

Signals serve as the core elements within a reactive system.
They play a crucial role in tracking and managing state changes, allowing the UI to respond automatically when the underlying data changes.
They are responsible for storing and managing data, as well as triggering updates across the system.

Signals are able to achieve this reactivity through the use of:

- **Getters**: A function responsible for retrieving the current value of a signal.
When called within a reactive context, it will give access to the current value of the signal.
- **Setters**: This function is responsible for updating the value of a signal.
To trigger reactivity, setters notify the system that the signal's value has changed, prompting anything that depends on the signal to re-evaluate and update accordingly.

<EraserLink
	href="https://app.eraser.io/workspace/maDvFw5OryuPJOwSLyK9?elements=lseAEjGlKLslaVsTlfej_g"
	preview="https://app.eraser.io/workspace/maDvFw5OryuPJOwSLyK9/preview?elements=lseAEjGlKLslaVsTlfej_g&type=embed"
/>

### Subscribers

Subscribers refer to other reactive contexts or components that depend on the value of a signal.
These automated responders keep the system up-to-date by re-evaluating and updating whenever the signal's value changes.

Subscribers work based on two main actions:
- **Observation**: The core function of a subscriber is to observe signals.
This keeps the subscriber informed about any changes to the signal(s) they're tracking.
- **Respond**: Once the signal has updated and the subscriber is notified, it triggers a re-evaluation of the dependent computations or UI updates.

[TODO: Some kind of image / code block??]