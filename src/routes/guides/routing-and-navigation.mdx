---
title: Routing & Navigation
order: 4
---

import { TabsCodeBlocks } from "~/ui/tab-code-blocks";

Solid Router simplifies routing in Solid applications to help developers manage navigation and rendering by defining routes using JSX or objects passed via props.

## Getting Started


**1. Install the Router**

This package is not included by default.

<TabsCodeBlocks>
<div id="npm">
```bash frame="none"
npm install @solidjs/router
```
</div>

<div id="yarn">
```bash frame="none"
 yarn add @solidjs/router
```
</div>
<div id="pnpm">
```bash frame="none"
pnpm i @solidjs/router
```
</div>
</TabsCodeBlocks>

**2. Setup the `<Router>` component**

Start your application by rendering the [Router](/solid-router/reference/components/router) component.
This component will match the URL to display the desired page.

```jsx
import { render } from "solid-js/web";
import { Router } from "@solidjs/router";

render(
  () => <Router />,
  document.getElementById("root")
);
```


**3. Provide a Root Level Layout**

This layout will not update on page change and is the ideal place for top-level navigation and [Context Providers](/concepts/context).

```jsx
import { render } from "solid-js/web";
import { Router } from "@solidjs/router";

const App = props => (
  <>
    <h1>Site Title</h1>
    {props.children}
  </>
)

render(() => (
  <Router root={App} />
), document.getElementById("root"));
```

**4. Add routes**

Each route is added to the `Router` using the [`Route`](/solid-router/reference/components/route) component.
Here, you specify a path and a component to render once the user navigates to that path.

```jsx
import { render } from "solid-js/web";
import { Router, Route } from "@solidjs/router";

import Home from "./pages/Home";
import Users from "./pages/Users";

const App = props => (
  <>
    <h1>Site Title</h1>
    {props.children}
  </>
)

render(() => (
  <Router root={App}>
    <Route path="/" component={Home} />
    <Route path="/users" component={Users} />
  </Router>
), document.getElementById("root"));
```

**5. Create a CatchAll Route (404 page)**

You can create catchall routes for pages not found at any nested level of the router.
Use `*` and optionally a parameter name to retrieve the rest of the path.

```jsx
import { render } from "solid-js/web";
import { Router, Route } from "@solidjs/router";

import Home from "./pages/Home";
import Users from "./pages/Users";
import NotFound from "./pages/NotFound";

const App = props => (
  <>
    <h1>My Site with lots of pages</h1>
    {props.children}
  </>
)

render(() => (
  <Router root={App}>
    <Route path="/" component={Home} />
    <Route path="/users" component={Users} />
    <Route path="*404" component={NotFound} />
  </Router>
), document.getElementById("root"));
```

**6. Create Links to Your Routes**

Use the `<A>` component to provide navigation to the application's routes.
Alternatively, you can use an anchor tag. However, the `<A>` component has additional functionality including properties for CSS `inactiveClass` and `activeClass`.

```jsx
import { render } from "solid-js/web";
import { Router, Route, A } from "@solidjs/router";

import Home from "./pages/Home";
import Users from "./pages/Users";
import NotFound from "./pages/NotFound";

const App = props => (
  <>
    <nav>
      <A href="/">Home</A>
      <A href="/users">Users</A>
    </nav>
    <h1>My Site with lots of pages</h1>
    {props.children}
  </>
);

render(() => (
  <Router root={App}>
    <Route path="/" component={Home} />
    <Route path="/users" component={Users} />
    <Route path="*NotFound" component={NotFound} />
  </Router>
), document.getElementById("root"));
```

## Lazy-loading Route Components

Using lazy to delay component loading until they are navigated to.

```jsx
import { lazy } from "solid-js";
import { render } from "solid-js/web";
import { Router, Route } from "@solidjs/router";

const Users = lazy(() => import("./pages/Users"));
const Home = lazy(() => import("./pages/Home"));

const App = props => (
  <>
    <h1>My Site with lots of pages</h1>
    {props.children}
  </>
)

render(() => (
  <Router root={App}>
    <Route path="/users" component={Users} />
    <Route path="/" component={Home} />
  </Router>
), document.getElementById("root"));
```

## Dynamic Routes

If you don't know the path ahead of time, you might want to treat part of the path as a flexible parameter that is passed on to the component.

```jsx
import { lazy } from "solid-js";
import { render } from "solid-js/web";
import { Router, Route } from "@solidjs/router";

const Users = lazy(() => import("./pages/Users"));
const User = lazy(() => import("./pages/User"));
const Home = lazy(() => import("./pages/Home"));

render(() => (
  <Router>
    <Route path="/users" component={Users} />
    <Route path="/users/:id" component={User} />
    <Route path="/" component={Home} />
  </Router>
 ), document.getElementById("root"));
```

The colon indicates that `id` can be any string, and as long as the URL fits that pattern,
the `<User>` component will show.


You can then access that `id` from within a route component with `useParams`.


**Note on Animation/Transitions**:
Routes that share the same path will be treated as the same route.
If you want to force re-render you can wrap your component in a keyed [`<Show>`](/reference/components/show) like:

```jsx
<Show when={params.something} keyed><MyComponent></Show>
```

## Validating Routes

Each path parameter can be validated using a `MatchFilter`.
This allows for more complex routing descriptions than just checking the presence of a parameter.

```jsx
import { lazy } from "solid-js";
import { render } from "solid-js/web";
import { Router, Route } from "@solidjs/router";
import type { SegmentValidators } from "./types";

const User = lazy(() => import("./pages/User"));

const filters: MatchFilters = {
  parent: ["mom", "dad"], // allow enum values
  id: /^\d+$/, // only allow numbers
  withHtmlExtension: (v: string) => v.length > 5 && v.endsWith(".html"), // we want an `*.html` extension
};

render(() => (
  <Router>
    <Route
      path="/users/:parent/:id/:withHtmlExtension"
      component={User}
      matchFilters={filters}
    />
  </Router>
), document.getElementById("root"));
```

Here, the `matchFilters` prop as been added.
This allows you to validate the `parent`, `id` and `withHtmlExtension` parameters against the filters defined in `filters`.
If the validation fails, the route will not match.

In this example:

- `/users/mom/123/contact.html` will match,
- `/users/dad/123/about.html` will match,
- `/users/aunt/123/contact.html` will **not** match as `:parent` is not 'mom' or 'dad',
- `/users/mom/me/contact.html` will **not** match as `:id` is not a number,
- `/users/dad/123/contact` will **not** match as `:withHtmlExtension` is missing `.html`.

### Optional Parameters

Parameters can be specified as optional by adding a question mark to the end of the parameter name:

```jsx
// Matches stories and stories/123 but not stories/123/comments
<Route path="/stories/:id?" component={Stories} />
```

### Wildcard Routes

While `:param` lets you match an arbitrary name at that point in the path, you can use `*` to match any end of the path:

```jsx
// Matches any path that begins with foo, including foo/, foo/a/, foo/a/b/c
<Route path="foo/*" component={Foo} />
```

If you want to expose the wild part of the path to the component as a parameter, you can name it:

```jsx
<Route path="foo/*any" component={Foo} />
```

Note that the wildcard token must be the last part of the path; `foo/*any/bar` won't create any routes.

### Multiple Paths

The `Routes` component also supports defining multiple paths using an array.
This allows a route to remain mounted and not rerender when switching between two or more locations that it matches:

```jsx
// Navigating from login to register does not cause the Login component to re-render
<Route path={["login", "register"]} component={Login} />
```

## Nested Routes

Only leaf `<Route>` nodes (innermost `<Route>` components) are given a route.


The following code won't work the way you expect.
It will only match `/users/:id` and it will only render `<User>`. `/users` will not be matched and `<Users>` will never be rendered.

```jsx
<Route path="/users" component={Users}>
  <Route path="/:id" component={User} />
</Route>
```

The following two route definitions both match the same URL `/users:id` and render the same component:

```jsx
<Route path="/users/:id" component={User} />

<Route path="/users">
  <Route path="/:id" component={User} />
</Route>
```

If you want to make the parent its own route, you have to specify it separately.
These examples will work. They both will match `/users` and `/users/:id`.

```jsx
<Route path="/users" component={Users} />
<Route path="/users/:id" component={User} />

<Route path="/users">
  <Route path="/" component={Users} />
  <Route path="/:id" component={User} />
</Route>
```

You can also take advantage of nesting by using `props.children` passed to the route component.

```jsx
function PageWrapper(props) {
  return (
    <div>
      <h1> We love our users! </h1>
      {props.children}
      <A href="/">Back Home</A>
    </div>
  );
}

<Route path="/users" component={PageWrapper}>
  <Route path="/" component={Users} />
  <Route path="/:id" component={User} />
</Route>;
```

The routes are still configured the same, but now the route components will appear inside the parent component where the `props.children` is declared.


You can nest indefinitely.
Just remember that only leaf nodes will become their own routes.
In this example, the only route created is `/layer1/layer2`, and it appears as three nested divs.

```jsx
<Route
  path="/"
  component={(props) =>
    <div>
      Onion starts here {props.children}
    </div>
  }
>
  <Route
    path="layer1"
    component={(props) =>
      <div>
        Another layer {props.children}
      </div>
    }
  >
    <Route path="layer2"
      component={() => <div>Innermost layer</div>}>
    </Route>
  </Route>
</Route>
```

## Load Functions

Even with smart caches, you can still have waterfalls with both view logic and with lazy-loaded code.
With load functions, data fetching is started parallel to loading the route, so it can be used as soon as possible.
The load function is called when the Route is loaded, or eagerly when links are hovered.


As its only argument, the load function is passed an object that you can use to access route information:

```jsx
import { lazy } from "solid-js";
import { Route } from "@solidjs/router";

const User = lazy(() => import("./pages/users/[id].js"));

// load function
function loadUser({params, location}) {
  // do loading
}
```

The load function is then passed in the `<Route>` definition:

```jsx
<Route path="/users/:id" component={User} load={loadUser} />;
```

---

A common pattern is to export the load function and data wrappers that correspond to a route from a dedicated route.data.js file.
This way, the data function can be imported without loading anything else.

```jsx
// src/pages/users/[id].data.js
import { cache } from "@solidjs/router";

export const getUser = cache(async (id) => {
  return (await fetch(`https://swapi.tech/api/people/${id}/`)).json();
}, "getUser");

export function loadUser({ params, location, intent }) {
  return getUser(params.id);
}
```

`loadUser` is passed an object which contains `params`, `location` and `intent`.
Here only `params` is being used.
The return value of the load function is passed to the page component when called at any time other than "preload", so you can initialize things in there, or use our new [Data APIs](/reference/solid-router/data-apis/create-async).
See [Load](/reference/solid-router/load-functions/load) for details.


Using `cache` has several benefits including preventing duplicate fetching.
See [cache](/reference/solid-router/data-apis/cache) for details.


`[id]` in `[id].data.js` is a convention and not required.


`loadUser` is called from the `<Route>`

```jsx
// src/index.jsx
import { lazy } from "solid-js";
import { render } from "solid-js/web";
import { Router, Route } from "@solidjs/router";
import { loadUser } from "./pages/users/[id].data.js";

const Home = lazy(() => import('./pages/Home'))
const User = lazy(() => import('./pages/users/[id]'))

render(() => (
  <Router>
    <Route path="/" component={Home} />
    <Route
      path="/users/:id"
      component={User}
      load={loadUser}
    />
  </Router>
), document.getElementById("root"));
```

`[id].jsx` contains the component that gets rendered.

```jsx
// [id].jsx
import { createAsync } from "@solidjs/router";
import { getUser } from "./[id].data";

export default function Users(props) {
  console.log('Users.props', props)
  const user = createAsync(() => getUser(props.params.id));
  return (
    <>
      <h1>User</h1>
      <div>
        <pre>{JSON.stringify(user(), null, 2)}</pre>
      </div>
    </>
  )
}
```

[`createAsync`](/reference/solid-router/data-apis/create-async) expects a promise and turns it into a [Signal](/routes/concepts/signals).


## Config Based Routing

You don't have to use JSX to set up your routes.
Instead, you can pass an array of route definitions:

```jsx
import { lazy } from "solid-js";
import { render } from "solid-js/web";
import { Router } from "@solidjs/router";

const routes = [
  {
    path: "/users",
    component: lazy(() => import("/pages/users.js")),
  },
  {
    path: "/users/:id",
    component: lazy(() => import("/pages/users/[id].js")),
    children: [
      {
        path: "/",
        component: lazy(() => import("/pages/users/[id]/index.js")),
      },
      {
        path: "/settings",
        component: lazy(() => import("/pages/users/[id]/settings.js")),
      },
      {
        path: "/*all",
        component: lazy(() => import("/pages/users/[id]/[...all].js")),
      },
    ],
  },
  {
    path: "/",
    component: lazy(() => import("/pages/index.js")),
  },
  {
    path: "/*all",
    component: lazy(() => import("/pages/[...all].js")),
  },
];

render(() =>
  <Router>{routes}</Router>,
  document.getElementById("root")
);
```

Also, you can pass a single route definition object for a single route:

```jsx
import { lazy } from "solid-js";
import { render } from "solid-js/web";
import { Router } from "@solidjs/router";

const route = {
  path: "/",
  component: lazy(() => import("/pages/index.js"))
};

render(() => <Router>{route}</Router>, document.getElementById("root"));
```

## Alternative Routers

### Hash Mode Router

By default, Solid Router uses `location.pathname` as the route path.
You can simply switch to hash mode by using `<HashRouter>`.

```jsx
import { HashRouter } from "@solidjs/router";

<HashRouter />;
```

### Memory Mode Router

You can also use a memory mode router for testing purposes.

```jsx
import { MemoryRouter } from "@solidjs/router";

<MemoryRouter />;
```

### SSR Routing

For SSR you can use the static router directly or use the browser Router which defaults to it on the server.
Just pass in the URL.

```jsx
import { isServer } from "solid-js/web";
import { Router } from "@solidjs/router";

<Router url={isServer ? req.url : ""} />;
```

## Router Primitives

Solid Router provides several primitives that read off the Router and Route context.

### useParams

Retrieves a reactive, store-like object containing the current route path parameters as defined in the `<Route>`.

```js
const params = useParams();

// fetch user based on the id path parameter
const [user] = createResource(() => params.id, fetchUser);
```

### useNavigate

Retrieves the method to do navigation.
The method accepts a path to navigate to and an optional object with the following options:

- resolve (_boolean_, default `true`): resolve the path against the current route
- replace (_boolean_, default `false`): replace the history entry
- scroll (_boolean_, default `true`): scroll to top after navigation
- state (_any_, default `undefined`): pass custom state to `location.state`

**Note:** The state is serialized using the [structured clone algorithm](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm) which does not support all object types.

```js
const navigate = useNavigate();

if (unauthorized) {
  navigate("/login", { replace: true });
}
```

### useLocation

Retrieves reactive `location` object useful for getting things like `pathname`:

```js
const location = useLocation();

const pathname = createMemo(() => parsePath(location.pathname));
```

### useSearchParams

Retrieves a tuple containing a reactive object to read the current location's query parameters and a method to update them.
The object is a proxy, so you must access properties to subscribe to reactive updates.
Note that values will be strings and property names will retain their casing.


The setter method accepts an object whose entries will be merged into the current query string. Values `''`, `undefined` and `null` will remove the key from the resulting query string.
Updates will behave just like a navigation.
The setter accepts the same optional second parameter as `navigate` and auto-scrolling is disabled by default.

```js
const [searchParams, setSearchParams] = useSearchParams();

return (
  <div>
    <span>Page: {searchParams.page}</span>
    <button
      onClick={() =>
        setSearchParams({ page: (parseInt(searchParams.page) || 0) + 1 })
      }
    >
      Next Page
    </button>
  </div>
);
```

### useIsRouting

Retrieves a signal that indicates whether the route is currently in a Transition.
This is useful for showing stale/pending state when the route resolution is Suspended during concurrent rendering.

```js
const isRouting = useIsRouting();

return (
  <div classList={{ "grey-out": isRouting() }}>
    <MyAwesomeConent />
  </div>
);
```

### useMatch

`useMatch` takes an accessor that returns the path and creates a Memo that returns match information if the current path matches the provided path.
This is useful for determining if a given path matches the current route.

```js
const match = useMatch(() => props.href);

return <div classList={{ active: Boolean(match()) }} />;
```

### useBeforeLeave

`useBeforeLeave` takes a function that will be called before leaving a route. The function will be called with:

- from (_Location_): current location (before change).
- to (_string | number_}: path passed to `navigate`.
- options (_NavigateOptions_}: options passed to `navigate`.
- preventDefault (_void function_): call to block the route change.
- defaultPrevented (_readonly boolean_): true if any previously called leave handlers called preventDefault().
- retry (_void function_, _force?: boolean_ ): call to retry the same navigation, perhaps after confirming with the user. Pass `true` to skip running the leave handlers again (ie force navigate without confirming).

Example usage:

```js
useBeforeLeave((e: BeforeLeaveEventArgs) => {
  if (form.isDirty && !e.defaultPrevented) {
    // preventDefault to block immediately and prompt user async
    e.preventDefault();
    setTimeout(() => {
      if (window.confirm("Discard unsaved changes - are you sure?")) {
        // user wants to proceed anyway so retry with force=true
        e.retry(true);
      }
    }, 100);
  }
});
```

## SPAs in Deployed Environments

When deploying applications that use a client-side router which does not rely on Server Side Rendering, you need to handle redirects to your index page so that loading from other URLs does not cause your CDN or Hosting to return not found for pages that aren't actually there.


Each provider has a different way of doing this.
For example, on Netlify you create a `_redirects` file that contains:

```
/*   /index.html   200
```

On Vercel you add a rewrites section to your `vercel.json`:

```json

{
  "rewrites": [
    {
      "source": "/(.*)",
      "destination": "/index.html"
    }
  ]
}
```

## Additional Routing details
- [Solid Router Components](/reference/solid-router/components/router)
- [Solid Router Data APIs](/reference/solid-router/data-apis/create-async)
- [Migration from 0.9.x to 0.10.x](https://docs.solidjs.com/routing/migration)

---
