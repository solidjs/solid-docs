---
title: use:*
order: 5
---

Custom directives attach reusable behavior to DOM elements, acting as syntactic sugar over `ref`. Theyâ€™re ideal for complex DOM interactions like scrolling, tooltips, or resizing, which are cumbersome to repeat in JSX.

A directive is a function with the following signature

```ts
function directive(element: HTMLElement, accessor: Accessor<any>): void
```

Directive functions are called at render time but before being added to the DOM. You can do whatever you'd like in them including create signals, effects, register clean-up etc.

```tsx
const [name, setName] = createSignal("");

function model(element: HTMLInputElement, accessor: Accessor<Signal<string>>) {
	const [field, setField] = accessor();
	createRenderEffect(() => (element.value = field()));
	element.addEventListener("input", ({ target }) => setField(target.value));
}

<input type="text" use:model={[name, setName]} />
```

To register with TypeScript extend the JSX namespace

```ts
declare module "solid-js" {
	namespace JSX {
		interface DirectiveFunctions {
			model: typeof model;
		}
	}
}
```

:::caution[Limitations]
Directives only work with native HTML elements (HTML/SVG/MathML/Custom Elements).
Directives are not forwarded and **won't work in user defined components**, such as `<MyComponent use:myinput={[..]}/>` [see also](https://github.com/solidjs/solid/discussions/722)
:::
