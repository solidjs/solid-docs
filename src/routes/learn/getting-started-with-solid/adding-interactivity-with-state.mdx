import Snippet from "../../../components/Snippet";
import { Tab, Tabs } from "../../../components/Tabs";
import { FrameworkAside } from "../../../components/FrameworkAside";
import { BasicCounter } from "../components/BasicCounter";
import { BasicBookshelf } from "../components/BasicBookshelf";

<title>Adding Interactivity with State</title>

# Adding Interactivity with State

In the previous lesson, we learned how to architect a Solid application using components and JSX. We then built a Bookshelf application using our new knowledge, but it's not quite complete. In this lesson, we'll learn about some building blocks that help us _manage application state_. We will then apply this knowledge to our Bookshelf application to bring it to life.

## A note on primitives

As we proceed through these tutorials, we'll start hearing about Solid _primitives_. Primitives are the building blocks of Solid applications. The first primitive that we'll be learning about is the _signal_.

## Managing basic state with signals

In Solid, the most basic way to manage state in our application is to use a _signal_. To create a signal, Solid provides a `createSignal` function:

```tsx
import { createSignal } from "solid-js";

const [count, setCount] = createSignal(0);
```

There's a lot going on here: first, we call `createSignal` with the initial value of state. In this case, our `count` is going to start at `0`. The `createSignal` function returns a two-element array and we use JavaScript _destructuring assignment_ to unpack this array. In this case, we assign the first element to a variable called `count` and the second element to a variable called `setCount`.

The first element, `count`, is an _accessor_ function (also referred to as a _getter_) that returns the current value of state. It's important to note that this is a _function that gets the current value_ rather than the value itself.

```tsx
import { createSignal } from "solid-js";

const [count, setCount] = createSignal(0);

console.log(count()); // 0
```

The second element, `setCount`, is a _setter_ function. If we want to increment our `count`, we can pass `count() + 1` to `setCount`:

```tsx
import { createSignal } from "solid-js";

const [count, setCount] = createSignal(0);

setCount(count() + 1);

console.log(count()); // 1
```

Note that, in order to see our `count` value's new value, we added our `console.log` statement after we used `setCount`.

A key to Solid's _reactive system_ is that we don't really have to do this. Instead, we can listen for&mdash;and instantly react to&mdash;any signal changes by using our next primitive: the _effect_.

## Reacting to changes with effects

The ability to react to signal changes underpins Solid's reactive system. The most basic way to do so is to use an _effect_. We can create an effect by using the `createEffect` hook:

```tsx
import { createSignal, createEffect } from "solid-js";

const [count, setCount] = createSignal(0);

createEffect(() => {
  console.log(count());
});

setCount(count() + 1);
```

To use `createEffect`, we pass it a function that will run whenever any signals on which that function depends update.

In this example, our effect depends on `count` and therefore the effect runs whenever `count` changes. Accordingly, we log `1` to the console just like before.

Automatic effect dependency tracking is made possible by `count` being a function. When the `count` function is called inside an effect, that effect is registered as a listener for the signal. This is why it's so important that our signals are functions!

## Rendering with signals

Now that we've gained some exposure to two of Solid's core primitives, signals and effects, it's time to add them into our components. Let's keep using our `count` example but, instead of logging the count, let's render it to the DOM:

<Tabs files={["Counter.tsx"]} selected="Counter.tsx">

```tsx
import { createSignal } from "solid-js";

function Counter() {
  const [count, setCount] = createSignal(0);

  return <div>Current count: {count()}</div>;
}
```

</Tabs>

<div>Current count: 0</div>

We see that, much like other variables, we can use signals inside our JSX code by including them inside curly braces. This component is not too interesting yet; so let's add the ability to increment our count. We can do this by adding `<button>` element and giving it a _click handler_. This click handler will increment our count by using the `setCount` function:

<Tabs files={["Counter.tsx"]} selected="Counter.tsx">

```tsx
import { createSignal } from "solid-js";

function Counter() {
  const [count, setCount] = createSignal(0);

  const increment = () => {
    setCount(count() + 1);
  };

  return (
    <div>
      Current count: {count()}
      <button onClick={increment}>Increment</button>
    </div>
  );
}
```

</Tabs>

<BasicCounter />

And now we have a functioning counter! Notably, our DOM updates whenever our `count` is incremented. Does this remind you of an effect? It should! In Solid, rendering is treated as an effect. A driving philosophy of Solid is that, by treating everything as a signal or an effect, we can better reason about our application.

## Revisting the bookshelf

We now have the tools necessary to make our Bookshelf application interactive. As a refresher, here's the current state of the app. It currently has the following components:

- `BookList`, a list of books on our Bookshelf
- `AddBook`, a form that will allow us to add more books to the shelf
- `Bookshelf`, our main application component that contains the other two

<Tabs files={["App.tsx", "BookList.tsx", "AddBook.tsx"]} selected="App.tsx">
  <Tab name="App.tsx">

```tsx
import { render } from "solid-js/web";
import { BookList } from "./BookList";
import { AddBook } from "./AddBook";

interface IBookshelfProps {
  name: string;
}

function Bookshelf(props: IBookshelfProps) {
  return (
    <div>
      <h1>{props.name}'s Bookshelf</h1>
      <BookList />
      <AddBook />
    </div>
  );
}

const root = document.getElementById("root");

if (root) {
  render(() => <Bookshelf name="Solid" />, root);
}
```

  </Tab>
  <Tab name="BookList.tsx">

```tsx
export function BookList() {
  return (
    <ul>
      <li>
        Code Complete{" "}
        <span style={{ "font-style": "italic" }}>(Steve McConnell)</span>
      </li>
      <li>
        The Hobbit{" "}
        <span style={{ "font-style": "italic" }}>(J.R.R. Tolkien)</span>
      </li>
    </ul>
  );
}
```

  </Tab>
  <Tab name="AddBook.tsx">

```tsx
export function AddBook() {
  return (
    <form>
      <label for="book-name">Book name</label>
      <input id="book-name" />
      <button type="submit">Add book</button>
    </form>
  );
}
```

  </Tab>
</Tabs>

As a first step to adding interactivity, let's add a signal that keeps track of our book list. We'll call it `books` and it wil live in the `BookList` component. Each book will have a `title` and an `author`.

<Tabs files={["App.tsx", "BookList.tsx", "AddBook.tsx"]} selected="BookList.tsx">
  <Tab name="App.tsx">

```tsx
import { render } from "solid-js/web";
import { BookList } from "./BookList";
import { AddBook } from "./AddBook";

interface IBookshelfProps {
  name: string;
}

function Bookshelf(props: IBookshelfProps) {
  return (
    <div>
      <h1>{props.name}'s Bookshelf</h1>
      <BookList />
      <AddBook />
    </div>
  );
}

const root = document.getElementById("root");

if (root) {
  render(() => <Bookshelf name="Solid" />, root);
}
```

  </Tab>
  <Tab name="BookList.tsx">

```tsx
import { createSignal } from "solid-js";

type Book = {
  title: string;
  author: string;
};

const initialBooks: Book[] = [
  { title: "Code Complete", author: "Steve McConnell" },
  { title: "The Hobbit", author: "J.R.R. Tolkien" },
];

export function BookList() {
  const [books, setBooks] = createSignal(initialBooks);

  return (
    <ul>
      <li>
        {books()[0].title}{" "}
        <span style={{ "font-style": "italic" }}>({books()[0].author})</span>
      </li>
      <li>
        {books()[1].title}{" "}
        <span style={{ "font-style": "italic" }}>({books()[1].author})</span>
      </li>
    </ul>
  );
}
```

  </Tab>
  <Tab name="AddBook.tsx">

```tsx
export function AddBook() {
  return (
    <form>
      <label for="book-name">Book name</label>
      <input id="book-name" />
      <button type="submit">Add book</button>
    </form>
  );
}
```

  </Tab>
</Tabs>

There are a couple things to note here:

First, while we had only used `createSignal` to maintain the value of a number in state thus far, it can manage all kinds of state. In our Bookshelf application, our signal is an array of objects.

Second, we're now using `books` directly in our JSX code. We call `books()` to access the signal array, and then access the _0th_ element of that array in the first list item and the _1st_ element of that array in the second list item. This will work, but it's not flexible: we want to handle a dynamic number of books.

## Looping over items

The best way to loop over items in Solid is the `<For />` component. The `<For />` component has an `each` prop, to which we can pass our `books()` array.

```tsx
<For each={books()}></For>
```

Inside the `For` component, we use a _callback function_ that will be applied to _each_ element in the array. In this instance, we want each `book` to be rendered inside an `<li>`.

```tsx
<For each={books()}>
  {(book) => {
    return (
      <li>
        {book.title} ({book.author})
      </li>
    );
  }}
</For>
```

Our `BookList` component now looks like this:

<Tabs files={["App.tsx", "BookList.tsx", "AddBook.tsx"]} selected="BookList.tsx">
  <Tab name="App.tsx">

```tsx
import { render } from "solid-js/web";
import { BookList } from "./BookList";
import { AddBook } from "./AddBook";

interface IBookshelfProps {
  name: string;
}

function Bookshelf(props: IBookshelfProps) {
  return (
    <div>
      <h1>{props.name}'s Bookshelf</h1>
      <BookList />
      <AddBook />
    </div>
  );
}

const root = document.getElementById("root");

if (root) {
  render(() => <Bookshelf name="Solid" />, root);
}
```

  </Tab>
  <Tab name="BookList.tsx">

```tsx
import { createSignal } from "solid-js";

type Book = {
  title: string;
  author: string;
};

const initialBooks: Book[] = [
  { title: "Code Complete", author: "Steve McConnell" },
  { title: "The Hobbit", author: "J.R.R. Tolkien" },
];

export function BookList() {
  const [books, setBooks] = createSignal(initialBooks);

  return (
    <ul>
      <For each={books()}>
        {(book) => {
          return (
            <li>
              {book.title}{" "}
              <span style={{ "font-style": "italic" }}>({book.author})</span>
            </li>
          );
        }}
      </For>
    </ul>
  );
}
```

  </Tab>
  <Tab name="AddBook.tsx">

```tsx
export function AddBook() {
  return (
    <form>
      <div>
        <label for="title">Book name</label>
        <input id="title" />
      </div>
      <div>
        <label for="author">Author</label>
        <input id="author" />
      </div>
      <button type="submit">Add book</button>
    </form>
  );
}
```

  </Tab>
</Tabs>

## Derived state

Solid makes it easy to track _derived state_. You can think of derived state as a computation based only on other information you're alread tracking in state. In our Bookshelf application, an example of derived state would be the number of books on our list: it's the length of our `books` array at any point in time.

In Solid, all we have to do to compute derived state is to create a _derived signal_: a function that relies on another signal:

```tsx
const totalBooks = () => books().length;
```

Now, our `totalBooks` function is a signal of its own and will always be up-to-date with the length of our `books` array.

<Tabs files={["App.tsx", "BookList.tsx", "AddBook.tsx"]} selected="BookList.tsx">
  <Tab name="App.tsx">

```tsx
import { render } from "solid-js/web";
import { BookList } from "./BookList";
import { AddBook } from "./AddBook";

interface IBookshelfProps {
  name: string;
}

function Bookshelf(props: IBookshelfProps) {
  return (
    <div>
      <h1>{props.name}'s Bookshelf</h1>
      <BookList />
      <AddBook />
    </div>
  );
}

const root = document.getElementById("root");

if (root) {
  render(() => <Bookshelf name="Solid" />, root);
}
```

  </Tab>
  <Tab name="BookList.tsx">

```tsx
import { createSignal } from "solid-js";

type Book = {
  title: string;
  author: string;
};

const initialBooks: Book[] = [
  { title: "Code Complete", author: "Steve McConnell" },
  { title: "The Hobbit", author: "J.R.R. Tolkien" },
];

export function BookList() {
  const [books, setBooks] = createSignal(initialBooks);

  const totalBooks = () => books().length;

  return (
    <>
      <h2>My books ({totalBooks()})</h2>
      <ul>
        <For each={books()}>
          {(book) => {
            return (
              <li>
                {book.title}{" "}
                <span style={{ "font-style": "italic" }}>({book.author})</span>
              </li>
            );
          }}
        </For>
      </ul>
    </>
  );
}
```

  </Tab>
  <Tab name="AddBook.tsx">

```tsx
export function AddBook() {
  return (
    <form>
      <div>
        <label for="title">Book name</label>
        <input id="title" />
      </div>
      <div>
        <label for="author">Author</label>
        <input id="author" />
      </div>
      <button type="submit">Add book</button>
    </form>
  );
}
```

  </Tab>
</Tabs>

## Lifting state up

We want to add a book to the list using our `AddBook` component. There's one problem though: how do we make the `setBooks` setter available to the `AddBooks` component?

We know that parents can pass props to children, but how do _sibling_ components pass props to each other? This is a common problem in Solid and the solution is generally to _lift state up_ to a common parent. In this case, our `books` signal can live in the `Bookshelf` component. Then, the `BookList` component can use the accessor (`books()`) and the `AddBook` component can use the setter (`setBooks`).

Let's start out by lifting our `books` signal up to `Bookshelf` and passing it back down to the `BookList` component. You can see the changes we have made in both the `App.tsx` and `BookList.tsx` files.

<Tabs files={["App.tsx", "BookList.tsx", "AddBook.tsx"]} selected="App.tsx">
  <Tab name="App.tsx">

```tsx
import { render } from "solid-js/web";
import { createSignal } from "solid-js";
import { BookList } from "./BookList";
import { AddBook } from "./AddBook";

export type Book = {
  title: string;
  author: string;
};

const initialBooks: Book[] = [
  { title: "Code Complete", author: "Steve McConnell" },
  { title: "The Hobbit", author: "J.R.R. Tolkien" },
];

interface IBookshelfProps {
  name: string;
}

function Bookshelf(props: IBookshelfProps) {
  const [books, setBooks] = createSignal(initialBooks);

  return (
    <div>
      <h1>{props.name}'s Bookshelf</h1>
      <BookList books={books()} />
      <AddBook />
    </div>
  );
}

const root = document.getElementById("root");

if (root) {
  render(() => <Bookshelf name="Solid" />, root);
}
```

  </Tab>
  <Tab name="BookList.tsx">

```tsx
import { Book } from "./App";

interface IBookListProps {
  books: Book[];
}

export function BookList(props: IBookListProps) {
  const totalBooks = () => props.books.length;

  return (
    <>
      <h2>My books ({totalBooks()})</h2>
      <ul>
        <For each={props.books}>
          {(book) => {
            return (
              <li>
                {book.title}{" "}
                <span style={{ "font-style": "italic" }}>({book.author})</span>
              </li>
            );
          }}
        </For>
      </ul>
    </>
  );
}
```

  </Tab>
  <Tab name="AddBook.tsx">

```tsx
export function AddBook() {
  return (
    <form>
      <div>
        <label for="title">Book name</label>
        <input id="title" />
      </div>
      <div>
        <label for="author">Author</label>
        <input id="author" />
      </div>
      <button type="submit">Add book</button>
    </form>
  );
}
```

  </Tab>
</Tabs>

Our array of books now lives in the `Bookshelf` component. We then pass `books()` to the `BookList` component. We can now access our books withing the `BookList` component by using `props.books`.

**Note:** You may have noticed that we called `books()` when we passed it to the `BookList` component&mdash;this is not a typo! In Solid, it's a best practice to call a signal accessor when you pass it to a component. In the background, Solid makes this a _reactive prop_ and reactivity will be tracked in the child component's JSX. (_Note: good place to link to a discussion/guide on props and reactivity_).

## Adding books to the list

Now that we have lifted state, we can add some books to the list. Let's pass our setter to the `AddBook` component and call `setBooks` when we click the `Add Book` button. You can see these changes in the `App.tsx` and `AddBook.tsx` files:

<Tabs files={["App.tsx", "BookList.tsx", "AddBook.tsx"]} selected="App.tsx">
  <Tab name="App.tsx">

```tsx
import { render } from "solid-js/web";
import { createSignal } from "solid-js";
import { BookList } from "./BookList";
import { AddBook } from "./AddBook";

export type Book = {
  title: string;
  author: string;
};

const initialBooks: Book[] = [
  { title: "Code Complete", author: "Steve McConnell" },
  { title: "The Hobbit", author: "J.R.R. Tolkien" },
];

interface IBookshelfProps {
  name: string;
}

function Bookshelf(props: IBookshelfProps) {
  const [books, setBooks] = createSignal(initialBooks);

  return (
    <div>
      <h1>{props.name}'s Bookshelf</h1>
      <BookList books={books()} />
      <AddBook setBooks={setBooks} />
    </div>
  );
}

const root = document.getElementById("root");

if (root) {
  render(() => <Bookshelf name="Solid" />, root);
}
```

  </Tab>
  <Tab name="BookList.tsx">

```tsx
import { Book } from "./App";

interface IBookListProps {
  books: Book[];
}

export function BookList(props: IBookListProps) {
  const totalBooks = () => props.books.length;

  return (
    <>
      <h2>My books ({totalBooks()})</h2>
      <ul>
        <For each={props.books}>
          {(book) => {
            return (
              <li>
                {book.title}{" "}
                <span style={{ "font-style": "italic" }}>({book.author})</span>
              </li>
            );
          }}
        </For>
      </ul>
    </>
  );
}
```

  </Tab>
  <Tab name="AddBook.tsx">

```tsx
import { Setter } from "solid-js";
import { Book } from "./App.tsx";

interface IAddBookProps {
  setBooks: Setter<Book[]>;
}

function AddBook(props: IAddBookProps) {
  const addBook: JSX.EventHandler<HTMLButtonElement, MouseEvent> = (event) => {
    event.preventDefault();
    props.setBooks([]);
  };

  return (
    <form>
      <div>
        <label for="title">Book name</label>
        <input id="title" />
      </div>
      <div>
        <label for="author">Author</label>
        <input id="author" />
      </div>
      <button type="submit" onClick={addBook}>
        Add book
      </button>
    </form>
  );
}
```

  </Tab>
</Tabs>

Inside `AddBook`, we created a function called `addBook` that is used as the _click handler_ for our form's button. Since we're submitting a real HTML form, we use `event.preventDefault()` to prevent the default form behavior of executing a post request. Next, we call `props.setBooks`, but we don't quite know what to pass to our setter.

We know we want to keep the existing books on the list and then add a new book that comes from our form input. To get the existing books, we could use two different approaches: we _could_ pass the `books` signal down to our `AddBook` component. While that would work, it's worth exploring the second option: using the _callback function_ form of the setter. We haven't used this yet, and the syntax is as follows:

```tsx
setCount((currentCount) => {
  return currentCount + 1;
});
```

By using this form, our setter has access to the current value of the signal.

That solves the first problem: our `addBook` function can be written as follows:

<Tabs>

```tsx
const addBook: JSX.EventHandler<HTMLButtonElement, MouseEvent> = (event) => {
  event.preventDefault();
  props.setBooks((books) => {
    return books;
  });
};
```

</Tabs>

Now, we need to append the text from our form inputs to this list. To do so, we can create a new signal inside the `AddBook` component to track the value of the inputs. We'll make sure this signal is always equal to the inputs' values by using its `onInput` handler. Additionally, we'll _bind_ the `newBook()` to the `value` attribute of our `input` to make sure our `input` always reflects the value of the signal.

Finally, we want to add the `newBook` to our books list and then clear the input field in case our user has more books to enter.

<Tabs files={["App.tsx", "BookList.tsx", "AddBook.tsx"]} selected="AddBook.tsx">
  <Tab name="App.tsx">

```tsx
import { render } from "solid-js/web";
import { createSignal } from "solid-js";
import { BookList } from "./BookList";
import { AddBook } from "./AddBook";

export type Book = {
  title: string;
  author: string;
};

const initialBooks: Book[] = [
  { title: "Code Complete", author: "Steve McConnell" },
  { title: "The Hobbit", author: "J.R.R. Tolkien" },
];

interface IBookshelfProps {
  name: string;
}

function Bookshelf(props: IBookshelfProps) {
  const [books, setBooks] = createSignal(initialBooks);

  return (
    <div>
      <h1>{props.name}'s Bookshelf</h1>
      <BookList books={books()} />
      <AddBook setBooks={setBooks} />
    </div>
  );
}

const root = document.getElementById("root");

if (root) {
  render(() => <Bookshelf name="Solid" />, root);
}
```

  </Tab>
  <Tab name="BookList.tsx">

```tsx
import { Book } from "./App";

interface IBookListProps {
  books: Book[];
}

export function BookList(props: IBookListProps) {
  const totalBooks = () => props.books.length;

  return (
    <>
      <h2>Total books ({totalBooks()})</h2>
      <ul>
        <For each={props.books}>
          {(book) => {
            return (
              <li>
                {book.title}{" "}
                <span style={{ "font-style": "italic" }}>({book.author})</span>
              </li>
            );
          }}
        </For>
      </ul>
    </>
  );
}
```

  </Tab>
  <Tab name="AddBook.tsx">

```tsx
import { createSignal, Setter, JSX } from "solid-js";
import { Book } from "./App.tsx";

interface IAddBookProps {
  setBooks: Setter<Book[]>;
}

const emptyBook: Book = { title: "", author: "" };

function AddBook(props: IAddBookProps) {
  const [newBook, setNewBook] = createSignal(emptyBook);

  const addBook: JSX.EventHandler<HTMLButtonElement, MouseEvent> = (event) => {
    event.preventDefault();
    props.setBooks((books) => [...books, newBook()]);
    setNewBook(emptyBook);
  };

  return (
    <form>
      <div>
        <label for="title">Book name</label>
        <input
          id="title"
          value={newBook().title}
          onInput={(e) => {
            setNewBook({ ...newBook(), title: e.currentTarget.value });
          }}
        />
      </div>
      <div>
        <label for="author">Author</label>
        <input
          id="author"
          value={newBook().author}
          onInput={(e) => {
            setNewBook({ ...newBook(), author: e.currentTarget.value });
          }}
        />
      </div>
      <button type="submit" onClick={addBook}>
        Add book
      </button>
    </form>
  );
}
```

  </Tab>
</Tabs>

**Note:** We used the spread operator to create an new books array inside our books setter. This is a common pattern in Solid and helps to make sure we create a new array rather than updated (or _mutating_) the existing signal array. By default, Solid uses referential equality checks when determining if a signal has updated.

## Test-driving our app

We now have a dynamic Bookshelf application! Try it out yourself: you should be able to add books using the `AddBook` component and see those books addded to the list in the `BookList` component.

<BasicBookshelf name="Solid" />
