---
title: modifyMutable
---

```tsx
function modifyMutable<T>(mutable: T, modifier: (state: T) => T): void;
```

This helper function simplifies making multiple changes to a mutable Store (as returned by [createMutable](#createMutable)) in a single [batch](/reference/reactive-utilities/batch), so that dependant computations update just once instead of once per update.
The first argument is the mutable Store to modify, and the second argument is a Store modifier such as those returned by [reconcile]('#reconcile') or [produce](#produce).

<Callout type="caution">
	If you pass in your own modifier function, beware that its argument is an
	unwrapped version of the Store.
</Callout>

For example, suppose we have a UI depending on multiple fields of a mutable:

```tsx
import { createMutable } from "solid-js/store";

const state = createMutable({
	user: {
		firstName: "John",
		lastName: "Smith",
	},
});

<h1>Hello {state.user.firstName + " " + state.user.lastName}</h1>;
```

Modifying n fields in sequence will cause the UI to update n times:

```tsx
state.user.firstName = "Jane";
state.user.lastName = "Doe";
```

To trigger just a single update, the fields can be modified using a `batch`:

```tsx
import { batch } from "solid-js";

batch(() => {
	state.user.firstName = "Jane";
	state.user.lastName = "Doe";
});
```

`modifyMutable` combined with `reconcile` or `produce` provides two alternate ways to do similar things:

```tsx
import { modifyMutable, reconcile } from "solid-js/store";

// Replace state.user with the specified object (deleting any other fields)
modifyMutable(
	state.user,
	reconcile({
		firstName: "Jane",
		lastName: "Doe",
	})
);
```

```tsx
import { modifyMutable, produce } from "solid-js/store";

// Modify two fields in batch, triggering just one update
modifyMutable(
	state,
	produce((state) => {
		state.user.firstName = "Jane";
		state.user.lastName = "Doe";
	})
);
```
