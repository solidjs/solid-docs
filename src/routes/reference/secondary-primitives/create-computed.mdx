---
title: createComputed
---

Creates a reactive computation that runs immediately before render, mainly used to synchronize or write to other reactive primitives, not for DOM side-effects.

## Import

```typescript
import { createComputed } from "solid-js";
```

## Type Signature

```typescript
function createComputed<Next, Init = Next>(
 *   fn: (v: Init | Next) => Next,
 *   value?: Init,
 *   options?: { name?: string }
 * ): void;
```

## Parameters

### `fn`

**Type:** `(v: Init | Next) => Next`

The computation function.
 Receives the previous value (or initial value, if set) and returns a new value. 
 Runs reactively when dependencies change.

### `value` 

**Type:** `Init`

Initial value for the computation. 
If provided, `fn` will never receive `undefined` as its first argument.

### `options` 

**Type:** `{ name?: string }` (optional)

Used in development to identify the computed effect.

## Return Value

**Type:** `void`

Registers a computation in the reactive system. Does _not_ return a value.

## Usage

```typescript
import { createComputed } from "solid-js";

createComputed((prev) => {
  // Compute the next value based on the previous value
  return prev + 1;
}, 0);
```

## Advanced Usage

### Using an Initial Value

```typescript
import { createComputed } from "solid-js";

createComputed((prev) => {
  // Compute the next value based on the previous value
  return prev + 1;
}, 0);
```

### Synchronizing State

```typescript
const [source, setSource] = createSignal("initial");
const [copy, setCopy] = createSignal("");

createComputed(() => setCopy(source()));
```

## Common Patterns

- Writing to other reactive primitives, such as signals or stores, based on dependencies.
- Performing computations that must happen before render, not after.
- Setting up synchronization between multiple signals without side effects.

## How It Works 

`createComputed` defines a reactive computation that tracks any signals or memos accessed within its function. 
Whenever any of those dependencies change, the computation is rescheduled to run before the next render. 
It is "pure" in the sense that it is not intended to cause side effects outside of updating other reactive primitives.

## Details

### Development vs Production

In development mode, passing a name in the options object can help with debugging and inspection in developer tools.
In production, the name has no effect.

### Error Handling

- Errors thrown from the computation function are caught and reported using Solid's error boundaries or global error handlers.
- Computations created outside a root (e.g. outside `createRoot` or a component) will never be disposed, and a warning is shown in development.

### Performance Characteristics

- Computed functions are optimized to run only when their tracked dependencies change.
- Avoid doing expensive work or side effects in createComputed; use for reactive synchronization.
- For memoized derived values, use createMemo. For post-render side effects (e.g., DOM or network), use createEffect.
