---
title: createSignal
---

Creates a reactive state primitive consisting of a getter (accessor) and a setter function that forms the foundation of Solid's reactivity system.

## Import

```typescript
import { createSignal } from "solid-js";
```

## Type Signature

```typescript
function createSignal<T>(): Signal<T | undefined>
function createSignal<T>(value: T, options?: SignalOptions<T>): Signal<T>
```

### Related Types

```typescript
type Signal<T> = [get: Accessor<T>, set: Setter<T>]

type Accessor<T> = () => T

type Setter<T> = {
  <U extends T>(value: Exclude<U, Function> | ((prev: T) => U)): U;
  <U extends T>(value: (prev: T) => U): U;
  <U extends T>(value: Exclude<U, Function>): U;
  <U extends T>(value: Exclude<U, Function> | ((prev: T) => U)): U;
}

interface SignalOptions<T> {
  name?: string;
  equals?: false | ((prev: T, next: T) => boolean);
  internal?: boolean;
}
```

## Parameters

### `value`

- **Type:** `T` 
- **Default:** `undefined`

The initial value for the signal. If no initial value is provided, the signal's type is automatically extended with `undefined`.

### `options` 

- **Type:** `SignalOptions<T>` 
- **Default:** `undefined`

Configuration object for the signal.

#### `name`

- **Type:** `string`
- **Default:** `undefined`

A name for the signal used for debugging purposes in development mode.

#### `equals`

- **Type:** `false | ((prev: T, next: T) => boolean)`
- **Default:** `false`

A custom comparison function to determine when the signal should update. 
If set to `false`, the signal will always update regardless of value equality. By default, signals use reference equality (`===`).

#### `internal`

- **Type:** `boolean`
- **Default:** `false`

Marks the signal as internal, preventing it from appearing in development tools. 
This is primarily used by Solid's internal systems.

## Return Value

- **Type:** `Signal<T>`

Returns a tuple `[getter, setter]` where:

- **getter**: An accessor function that returns the current value and tracks dependencies when called within a reactive context
- **setter**: A function that updates the signal's value and notifies all dependent computations

## Usage

### Creating a signal with an initial value

```typescript
const [count, setCount] = createSignal(0);

console.log(count()); // 0
setCount(5);
console.log(count()); // 5
```

### Creating a signal without an initial value

```typescript
const [name, setName] = createSignal<string>();

console.log(name()); // undefined
setName("John");
console.log(name()); // "John"
```

### Functional updates

```typescript
const [count, setCount] = createSignal(0);

setCount(prev => prev + 1);
console.log(count()); // 1

setCount(c => c * 2);
console.log(count()); // 2
```

## Advanced Usage

### Using a custom equality function

```typescript
const [user, setUser] = createSignal(
  { name: "John", age: 25 },
  { 
    equals: (prev, next) => prev.name === next.name && prev.age === next.age 
  }
);

// This won't trigger updates because the values are considered equal
setUser({ name: "John", age: 25 });
```

### Disabling equality checking

```typescript
const [data, setData] = createSignal([], { equals: false });

// This will always trigger updates, even with the same array reference
setData([]);
```

### Development debugging

```typescript
const [state, setState] = createSignal(
  { loading: false, data: null },
  { name: "apiState" }
);
```

## Common Patterns

### Boolean toggle

```typescript
const [isOpen, setIsOpen] = createSignal(false);
const toggle = () => setIsOpen(prev => !prev);
```

### Object updates

```typescript
const [user, setUser] = createSignal({ name: "John", age: 25 });

// Update specific property
const updateName = (newName: string) => 
  setUser(prev => ({ ...prev, name: newName }));
```

## How It Works

Signals are the foundational primitive of SolidJS's fine-grained reactivity system. 
When you call the accessor function within a reactive context (like inside [`createEffect`](/reference/basic-reactivity/create-effect) or a component's JSX), it automatically establishes a dependency relationship. 
Any subsequent calls to the setter will trigger updates only to the specific computations that depend on that signal.

```typescript
const [name, setName] = createSignal("John");

// This effect will re-run whenever name changes
createEffect(() => {
  console.log(`Hello, ${name()}!`);
});

setName("Jane"); // Logs: "Hello, Jane!"
```

## Details

### Reactivity System Integration

- **Effects**: Automatically track signal reads and re-run when values change
- **Memos**: Cache computed values based on signal dependencies
- **Resources**: Use signals internally for state management
- **Stores**: Built on top of signals with additional mutation tracking

### Equality Checking

By default, signals use strict equality (`===`) to determine if a value has changed. 
This means primitive values are compared by value, while objects and arrays are compared by reference. 
Setting a signal to the same reference will not trigger updates, but setting it to a new object or array, even if it has identical properties, will trigger updates.

### Function Values

When your signal stores a function as its value, updating it requires special care because the setter treats functions as updater functions by default.
To set a function as the actual value, wrap it in another function:

```typescript
const [fn, setFn] = createSignal(() => "hello");

// ❌ This treats your function as an updater, not the new value
setFn(() => "world"); // Signal becomes "world"

// ✅ Wrap your function to store it as the actual value  
setFn(() => () => "world"); // Signal becomes () => "world" (function)
```

The pattern is: `setSignal(() => yourNewFunction)`. 
The outer function is the updater, the inner function is your actual value.

### Development vs Production

In development mode, signals track additional metadata to aid debugging. 
The `name` option allows you to assign meaningful names to signals, making them easier to identify in developer tools. 
Additionally, Solid issues warnings if signals are created outside of reactive contexts, helping you catch potential issues early.

In production mode, all debugging metadata is stripped away for optimal performance. 
Dev-only options like `name` are ignored, and no warnings are issued, ensuring that your application runs as efficiently as possible.

### Error Handling

- If an equality function throws an error, it's caught and handled by Solid's error boundary system
- Setter functions are synchronous and will throw immediately if errors occur
- Reading a signal outside of a reactive context is safe but won't establish tracking

### Performance Characteristics

- Signals are optimized for frequent reads and infrequent writes
- The equality function is called on every setter invocation
- Custom equality functions should be fast and pure
- Avoid creating signals inside frequently-called functions