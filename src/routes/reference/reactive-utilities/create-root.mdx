---
title: createRoot
---

Creates a new non-tracked reactive context ("root") that controls the lifetime and cleanup of all reactive computations and resources created within it.

## Import

```typescript
import { createRoot } from "solid-js";
```

## Type Signature

```typescript
function createRoot<T>(fn: RootFunction<T>, detachedOwner?: Owner | null): T
```

### Related Types

```typescript
type RootFunction<T> = (dispose: () => void) => T

interface Owner {
  owned: Computation<any>[] | null;
  cleanups: (() => void)[] | null;
  owner: Owner | null;
  context: any | null;
  sourceMap?: SourceMapValue[];
  name?: string;
}
```

## Parameters

### `fn`

**Type:** `RootFunction<T>`

A function that defines the reactive scope for this root. It receives a `dispose` function as its argument that, when called, will dispose of all resources created within this root.

### `detachedOwner`

**Type:** `Owner | null` (optional)

An optional owner for the new root. 
If provided, the new root will inherit context from this owner; otherwise, it inherits from the current owner.

## Return Value

**Type:** `T`

Returns the value produced by the `fn` function.

## Usage

### Basic Example

```typescript
const result = createRoot(() => {
  const [count, setCount] = createSignal(0);
  createEffect(() => console.log("Count:", count()));
  return { count, setCount };
});

console.log(result.count()); // 0
```

### Using the Dispose Function

```typescript
const cleanup = createRoot(dispose => {
  const [data, setData] = createSignal("initial");
  createEffect(() => console.log("Data changed:", data()));
  return dispose; // expose cleanup function
});

// Later, call cleanup() to clean up all computations in the root
cleanup();
```

### Without Dispose Argument

If you donâ€™t need to manually clean up, you can omit the `dispose` argument:

```typescript
const value = createRoot(() => {
  const [signal] = createSignal("hello");
  return signal();
});

console.log(value); // "hello"
```

## Details

### What is a Root?

A root is an ownership boundary for Solid's reactivity system. 
All signals, effects, memos, and resources created inside a root are owned by it. 
When the root is disposed, everything it owns is cleaned up together. 
This ensures proper memory management and cleanup in larger apps or isolated scopes.

### When to Use createRoot

Use `createRoot` when you need to control the lifecycle of a group of signals, effects, or resources that are not tied to a component. 
It is especially useful for app bootstrapping, isolated test cases, or whenever you need to guarantee cleanup of reactive resources.

### Lifetime and Cleanup

Calling the `dispose` function cleans up all computations, signals, and resources created within the root. 
If you do not use the `dispose` argument, the root is considered "unowned" and will not be tracked for disposal, which is suitable for short-lived or throwaway computations.

### Ownership and Context

Roots can be nested. 
The `detachedOwner` argument allows you to explicitly set the parent owner for the new root, which is useful for advanced scenarios like context propagation or testing. 
By default, roots inherit context from their parent unless `detachedOwner` is set.

### Error Handling

- If the function passed to `createRoot` throws, Solid ensures proper cleanup.
- The `dispose` function is safe to call multiple times; subsequent calls are no-ops.


## Performance Considerations

- Creating roots is lightweight; disposal traverses and cleans the ownership tree.
- Unowned roots are slightly more efficient, but do not provide cleanup guarantees.
- Avoid creating many short-lived roots in performance-critical code.