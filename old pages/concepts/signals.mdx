---
title: Signals
order: 2
use_cases: 'always, any solid project, state management, reactive data, core functionality'
tags:
  - always
  - state-management
  - reactivity
  - fundamentals
  - core
version: '1.0'
---

Signals are the **core primitive for state** in Solid.
They provide a way to store a value, read it, and update it.
When a signal changes, anything that depends on it will update automatically.

Signals can represent any kind of state in your application:  
- simple values like numbers or strings  
- complex values like objects or arrays  
- application state such as the current user, theme, or page

For an overview of how signals fit into Solidâ€™s reactive model, see [Reactivity Basics](/reactivity/basics).

## Creating a signal

Use [`createSignal`](/reference/basic-reactivity/create-signal) from `solid-js` to create a signal.  
It returns a pair of functions:  
- a **getter** to read the value  
- a **setter** to update the value  

```jsx
import { createSignal } from "solid-js";

const [count, setCount] = createSignal(0);
//       ^ getter   ^ setter
```

:::note
The syntax using `[` and `]` is called [array destructuring](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment).

This lets you extract values from the array.
In the context of `createSignal`, the first value is the getter function, and the second value is the setter function.
:::

## Accessing values

The getter function returned by `createSignal` is used to access the value of the signal.
Call the getter function with no arguments to read the current value:

```jsx
console.log(count()); // 0
```

## Updating values

The setter function returned by `createSignal` is used to update the value of the signal.
This function takes an argument that represents the new value of the signal:

```jsx
setCount(count() + 1);

console.log(count()); // 1
```

The setter function can also take a function that passes the previous value.

```jsx
setCount((prevCount) => prevCount + 1);

console.log(count()); // 1
```

## Reactivity

Signals are **reactive**, which means that they automatically update when their value changes.
For example, using a signal inside JSX automatically makes the DOM update when the signal changes:

```jsx
function Counter() {
	const [count, setCount] = createSignal(0);
	const increment = () => setCount((prev) => prev + 1);

	return (
		<div>
			<span>Count: {count()}</span> {/* Updates when `count` changes */}
			<button type="button" onClick={increment}>
				Increment
			</button>
		</div>
	);
}
```

To learn how signals connect to effects and tracking scopes, see:
- [Reactive Side Effects](/reactivity/effects)
- [Memoized Computations](/reactivity/memo)

## Related Pages

- [Reactivity Basics](/reactivity/basics)
- [Reactive Side Effects](/reactivity/effects)
- [Memoized Computations](/reactivity/memo)
- [Introduction to Components](/components/intro)
