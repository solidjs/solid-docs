---
title: createSignal
---

Creates a reactive state primitive consisting of a getter (accessor) and a setter function that forms the foundation of Solid's reactivity system.

## Import

```typescript
import { createSignal } from "solid-js";
```

## Type Signature

```typescript
function createSignal<T>(): Signal<T | undefined>
function createSignal<T>(value: T, options?: SignalOptions<T>): Signal<T>
```

### Related Types

```typescript
type Signal<T> = [get: Accessor<T>, set: Setter<T>]

type Accessor<T> = () => T

type Setter<T> = {
  <U extends T>(value: Exclude<U, Function> | ((prev: T) => U)): U;
  <U extends T>(value: (prev: T) => U): U;
  <U extends T>(value: Exclude<U, Function>): U;
  <U extends T>(value: Exclude<U, Function> | ((prev: T) => U)): U;
}

interface SignalOptions<T> {
  name?: string;
  equals?: false | ((prev: T, next: T) => boolean);
  internal?: boolean;
}
```

## Parameters

### `value`

**Type:** `T` (optional)

The initial value for the signal. If no initial value is provided, the signal's type is automatically extended with `undefined`.

### `options` 

**Type:** `SignalOptions<T>` (optional)

Configuration object for the signal.

#### `name`

**Type:** `string` (optional)

A name for the signal used for debugging purposes in development mode.

#### `equals`

**Type:** `false | ((prev: T, next: T) => boolean)` (optional)

A custom comparison function to determine when the signal should update. 
If set to `false`, the signal will always update regardless of value equality. By default, signals use reference equality (`===`).

#### `internal`

**Type:** `boolean` (optional)

Marks the signal as internal, preventing it from appearing in development tools. 
This is primarily used by Solid's internal systems.

## Return Value

**Type:** `Signal<T>`

Returns a tuple `[getter, setter]` where:

- **getter**: An accessor function that returns the current value and tracks dependencies when called within a reactive context
- **setter**: A function that updates the signal's value and notifies all dependent computations

## Basic Usage

### Creating a signal with an initial value

```typescript
const [count, setCount] = createSignal(0);

console.log(count()); // 0
setCount(5);
console.log(count()); // 5
```

### Creating a signal without an initial value

```typescript
const [name, setName] = createSignal<string>();

console.log(name()); // undefined
setName("John");
console.log(name()); // "John"
```

### Functional updates

```typescript
const [count, setCount] = createSignal(0);

setCount(prev => prev + 1);
console.log(count()); // 1

setCount(c => c * 2);
console.log(count()); // 2
```

## Advanced Usage

### Using a custom equality function

```typescript
const [user, setUser] = createSignal(
  { name: "John", age: 25 },
  { 
    equals: (prev, next) => prev.name === next.name && prev.age === next.age 
  }
);

// This won't trigger updates because the values are considered equal
setUser({ name: "John", age: 25 });
```

### Disabling equality checking

```typescript
const [data, setData] = createSignal([], { equals: false });

// This will always trigger updates, even with the same array reference
setData([]);
```

### Development debugging

```typescript
const [state, setState] = createSignal(
  { loading: false, data: null },
  { name: "apiState" }
);
```

## Common Patterns

### Boolean toggle

```typescript
const [isOpen, setIsOpen] = createSignal(false);
const toggle = () => setIsOpen(prev => !prev);
```

### Object updates

```typescript
const [user, setUser] = createSignal({ name: "John", age: 25 });

// Update specific property
const updateName = (newName: string) => 
  setUser(prev => ({ ...prev, name: newName }));
```

## How It Works

Signals are the foundational primitive of SolidJS's fine-grained reactivity system. 
When you call the accessor function within a reactive context (like inside [`createEffect`](/reference/basic-reactivity/create-effect) or a component's JSX), it automatically establishes a dependency relationship. 
Any subsequent calls to the setter will trigger updates only to the specific computations that depend on that signal.

```typescript
const [name, setName] = createSignal("John");

// This effect will re-run whenever name changes
createEffect(() => {
  console.log(`Hello, ${name()}!`);
});

setName("Jane"); // Logs: "Hello, Jane!"
```

## Details

### Reactivity System Integration

- **Effects**: Automatically track signal reads and re-run when values change
- **Memos**: Cache computed values based on signal dependencies
- **Resources**: Use signals internally for state management
- **Stores**: Built on top of signals with additional mutation tracking

### Equality Checking

By default, signals use strict equality (`===`) to determine if a value has changed:

- Primitive values are compared by value
- Objects and arrays are compared by reference
- Setting a signal to the same reference won't trigger updates
- Setting a signal to a new object with identical properties will trigger updates

### Function Values

When your signal stores a function as its value, updating it requires special care because the setter treats functions as updater functions by default.
To set a function as the actual value, wrap it in another function:

```typescript
const [fn, setFn] = createSignal(() => "hello");

// ❌ This treats your function as an updater, not the new value
setFn(() => "world"); // Signal becomes "world"

// ✅ Wrap your function to store it as the actual value  
setFn(() => () => "world"); // Signal becomes () => "world" (function)
```

The pattern is: `setSignal(() => yourNewFunction)`. 
The outer function is the updater, the inner function is your actual value.

### Development vs Production

**Development mode:**
- Signals track additional metadata for debugging
- The `name` option provides useful names in dev tools
- Warnings are issued for signals created outside reactive contexts

**Production mode:**
- Debugging metadata is stripped
- Dev-only options like `name` are ignored
- No warnings are issued

### Error Handling

- If an equality function throws an error, it's caught and handled by Solid's error boundary system
- Setter functions are synchronous and will throw immediately if errors occur
- Reading a signal outside of a reactive context is safe but won't establish tracking

### Performance Characteristics

- Signals are optimized for frequent reads and infrequent writes
- The equality function is called on every setter invocation
- Custom equality functions should be fast and pure
- Avoid creating signals inside frequently-called functions